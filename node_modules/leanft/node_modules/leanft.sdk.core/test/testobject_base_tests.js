// (c) Copyright 2015 Hewlett Packard Enterprise Development LP

/**
 * Created on 24/11/2015.
 * Unittests for the test object base and the description base.
 */

var assert = require("assert");
var sinon = require("sinon");
var TestObjectBase = require("../lib/testobject_base.js").TestObjectBase;

describe("TestObjectBase unit tests",function(){
    var testObjectUnderTest;
    beforeEach(function() {
        testObjectUnderTest = new TestObjectBase();
    });

    describe("highlight", function(){
        beforeEach(function(){
            sinon.stub(testObjectUnderTest,"_executeCommand");
        });
        it("should call the _executeCommand method and pass the method name",function(){
            testObjectUnderTest.highlight();
            assert(testObjectUnderTest._executeCommand.calledOnce);
            assert.equal(testObjectUnderTest._executeCommand.firstCall.args[0], "highlight");
        });
        it("should return the same promise that was returned from _executeCommand method",function(){
            var promise = {};
            testObjectUnderTest._executeCommand.returns(promise);
            var res = testObjectUnderTest.highlight();
            assert.strictEqual(res,promise);
        });
    });

    describe("exists", function(){
        beforeEach(function(){
            sinon.stub(testObjectUnderTest,"_executeCommand");
        });
        it("should call the _executeCommand method and pass the method name",function(){
            testObjectUnderTest.exists();
            assert(testObjectUnderTest._executeCommand.calledOnce);
            assert.equal(testObjectUnderTest._executeCommand.firstCall.args[0], "Exist");
        });
        it("should return the same promise that was returned from _executeCommand method",function(){
            var promise = {};
            testObjectUnderTest._executeCommand.returns(promise);
            var res = testObjectUnderTest.exists();
            assert.strictEqual(res,promise);
        });
        it("should throw error if null passed", function(){
            assert.throws(function(){
                testObjectUnderTest.exists(null);
            });
        });
        it("should pass the method name and timeout value if passed", function(){
            testObjectUnderTest.exists(5000);
            assert.deepEqual(testObjectUnderTest._executeCommand.firstCall.args, ["Exist", 5000]);
        });
    });

    describe("highlightMatches", function() {
        var testObjectMock;
        var descMock;

        beforeEach(function(){
            sinon.stub(testObjectUnderTest,"_executeCommand");

            testObjectUnderTest._session = {
                factory:{
                    create: sinon.stub()
                }
            };

            testObjectMock = {};

            testObjectUnderTest._session.factory.create.returns(testObjectMock);

            descMock = {
                _toJSON: function() {
                    return {
                        Properties: {tagName: "a"}
                    };
                }
            };
        });

        it("should call _executeCommand with null description if null description passed", function() {
            testObjectUnderTest.highlightMatches(null);

            assert(testObjectUnderTest._executeCommand.calledOnce);
            assert(testObjectUnderTest._executeCommand.calledWith("HighlightAllMatchingChildren", null));
        });

        it("should call _executeCommand with null description if null description passed and flag set", function() {
            testObjectUnderTest.highlightMatches(null, true);

            assert(testObjectUnderTest._executeCommand.calledOnce);
            assert(testObjectUnderTest._executeCommand.calledWith("HighlightAllMatchingChildren", null));
        });

        it("should add Type: Description and micclass to the description JSON", function() {
            testObjectUnderTest.highlightMatches(descMock);

            assert(testObjectUnderTest._executeCommand.calledOnce);
            assert.equal(testObjectUnderTest._executeCommand.getCall(0).args[0].toLowerCase(),"highlightallmatchingchildren");
            assert.deepEqual(testObjectUnderTest._executeCommand.getCall(0).args[1].Type, "Description");
        });

        it("should not add native class if flag set to true", function() {
            var expectedFilter = {
                Properties: {
                    tagName: "a"
                },
                Type: "Description"
            };

            testObjectUnderTest.highlightMatches(descMock, true);

            assert(testObjectUnderTest._executeCommand.calledOnce);
            assert.equal(testObjectUnderTest._executeCommand.getCall(0).args[0].toLowerCase(),"highlightallmatchingchildren");
            assert.deepEqual(testObjectUnderTest._executeCommand.getCall(0).args[1], expectedFilter);
        });

        it("should use native class of the test object", function() {
            testObjectMock._nativeClass = "SomeType";

            testObjectUnderTest.highlightMatches(descMock);

            assert(testObjectUnderTest._executeCommand.calledOnce);
            assert.equal(testObjectUnderTest._executeCommand.getCall(0).args[0].toLowerCase(),"highlightallmatchingchildren");
            assert.deepEqual(testObjectUnderTest._executeCommand.getCall(0).args[1].Properties.micclass, "SomeType");
        });

        it("should use _nativeTypeFieldName of the test object if defined", function() {
            testObjectMock._nativeClass = "SomeType";
            testObjectMock._nativeTypeFieldName = "SomeNativeTypeFieldName";

            testObjectUnderTest.highlightMatches(descMock);

            assert(testObjectUnderTest._executeCommand.calledOnce);
            assert.equal(testObjectUnderTest._executeCommand.getCall(0).args[0].toLowerCase(),"highlightallmatchingchildren");
            assert.deepEqual(testObjectUnderTest._executeCommand.getCall(0).args[1].Properties.SomeNativeTypeFieldName
                , "SomeType");
        });

        it("should return the result of _executeCommand as is", function() {
            testObjectUnderTest._executeCommand.returns("aaa");

            var res = testObjectUnderTest.highlightMatches(descMock);
            assert.strictEqual(res, "aaa");
        });
    });

    describe("$$ - findChildren", function() {
        var testObjectMock;
        var descMock;

        beforeEach(function(){
            sinon.stub(testObjectUnderTest,"_executeCommand");

            testObjectUnderTest._session = {
                factory:{
                    create: sinon.stub()
                }
            };

            testObjectMock = {};

            testObjectUnderTest._session.factory.create.returns(testObjectMock);

            descMock = {
                _toJSON: function() {
                    return {
                        Properties: {a: "aa"}
                    };
                }
            };
        });

        it("should call _executeCommand with null description if null description passed", function() {
            testObjectUnderTest.$$(null);

            assert(testObjectUnderTest._executeCommand.calledOnce);
            assert(testObjectUnderTest._executeCommand.calledWith("ChildObjects", null));
        });

        it("should call _executeCommand with null description if null description passed and flag set", function() {
            testObjectUnderTest.$$(null, true);

            assert(testObjectUnderTest._executeCommand.calledOnce);
            assert(testObjectUnderTest._executeCommand.calledWith("ChildObjects", null));
        });

        it("should add Type: Description and micclass to the description JSON", function() {
            testObjectUnderTest.$$(descMock);

            assert(testObjectUnderTest._executeCommand.calledOnce);
            assert.equal(testObjectUnderTest._executeCommand.getCall(0).args[0].toLowerCase(),"childobjects");
            assert.deepEqual(testObjectUnderTest._executeCommand.getCall(0).args[1].Type, "Description");
        });

        it("should not add native class if flag set to true", function() {
            var expectedFilter = {
                Properties: {
                    a: "aa"
                },
                Type: "Description"
            };

            testObjectUnderTest.$$(descMock, true);

            assert(testObjectUnderTest._executeCommand.calledOnce);
            assert.equal(testObjectUnderTest._executeCommand.getCall(0).args[0].toLowerCase(),"childobjects");
            assert.deepEqual(testObjectUnderTest._executeCommand.getCall(0).args[1], expectedFilter);
        });

        it("should use native class of the test object", function() {
           testObjectMock._nativeClass = "SomeType";

            testObjectUnderTest.$$(descMock);

            assert(testObjectUnderTest._executeCommand.calledOnce);
            assert.equal(testObjectUnderTest._executeCommand.getCall(0).args[0].toLowerCase(),"childobjects");
            assert.deepEqual(testObjectUnderTest._executeCommand.getCall(0).args[1].Properties.micclass, "SomeType");
        });

        it("should use _nativeTypeFieldName of the test object if defined", function() {
            testObjectMock._nativeClass = "SomeType";
            testObjectMock._nativeTypeFieldName = "SomeNativeTypeFieldName";

            testObjectUnderTest.$$(descMock);

            assert(testObjectUnderTest._executeCommand.calledOnce);
            assert.equal(testObjectUnderTest._executeCommand.getCall(0).args[0].toLowerCase(),"childobjects");
            assert.deepEqual(testObjectUnderTest._executeCommand.getCall(0).args[1].Properties.SomeNativeTypeFieldName
                , "SomeType");
        });

        it("should return the result of _executeCommand as is", function() {
            testObjectUnderTest._executeCommand.returns("aaa");

            var res = testObjectUnderTest.$$(descMock);
            assert.strictEqual(res, "aaa");
        });
    });

    describe("_getResultValue", function() {
        beforeEach(function() {
            testObjectUnderTest._init(null, null, null);
        });

        it("should return null if null passed", function() {
            assert.strictEqual(testObjectUnderTest._getResultValue(null), null);
        });

        it("should return simple value as is", function() {
            assert.strictEqual(testObjectUnderTest._getResultValue("aaa"), "aaa");
        });

        it("should return array of simple values as is", function() {
            assert.deepEqual(testObjectUnderTest._getResultValue([1, "aaa"]), [1, "aaa"]);
        });

        describe("Type: TestObject", function() {
            var testObjectMock;

            beforeEach(function() {
                testObjectUnderTest._session = {
                    factory: {
                        createByNativeClass: sinon.stub()
                    }
                };

                testObjectMock = {};
                testObjectUnderTest._session.factory.createByNativeClass.returns(testObjectMock);
            });

            it("should throw error if test object does not have server cookie", function() {
                assert.throws(function(){
                    testObjectUnderTest._getResultValue({
                        Type: "TestObject"
                    });
                });
            });

            it("should call createByNativeClass and pass it the class of the TestObject", function() {
                testObjectUnderTest._getResultValue({
                    Type: "TestObject",
                    ServerCookie: 123,
                    Class: "SomeClass"
                });

                assert(testObjectUnderTest._session.factory.createByNativeClass.calledOnce);
                assert.equal(testObjectUnderTest._session.factory.createByNativeClass.getCall(0).args[0],
                    "SomeClass");
            });

            it("should pass sub class to createByNativeClass if defined", function() {
                testObjectUnderTest._getResultValue({
                    Type: "TestObject",
                    ServerCookie: 123,
                    Class: "SomeClass",
                    SubTypeInfo: {
                        SimClass: "SubClass"
                    }
                });

                assert(testObjectUnderTest._session.factory.createByNativeClass.calledOnce);
                assert.equal(testObjectUnderTest._session.factory.createByNativeClass.getCall(0).args[0],
                    "SomeClass");
                assert.equal(testObjectUnderTest._session.factory.createByNativeClass.getCall(0).args[1],
                    "SubClass");
            });

            it("should set the cookie of the created test object", function() {
                testObjectUnderTest._getResultValue({
                    Type: "TestObject",
                    ServerCookie: 123,
                    Class: "SomeClass"
                });

                assert.strictEqual(testObjectMock._cookie, 123);
            });

            it("should return the created test object", function() {
                var res = testObjectUnderTest._getResultValue({
                    Type: "TestObject",
                    ServerCookie: 123,
                    Class: "SomeClass"
                });

                assert.strictEqual(res, testObjectMock);
            });
        });

        describe("Type: DynamicProxy", function() {
            var nativeObjProto = require("../lib/native_object.js").prototype;

            beforeEach(function() {
                sinon.stub(nativeObjProto, "_fillKeysFromMembers", function() {
                    return this;
                });
                testObjectUnderTest._session = {someKey: "value"};
            });

            afterEach(function() {
                nativeObjProto._fillKeysFromMembers.restore();
            });

            it("should throw error if native object does not have server cookie", function() {
                assert.throws(function(){
                    testObjectUnderTest._getResultValue({
                        Type: "DynamicProxy"
                    });
                });
            });

            it("should create a NativeObject with correct cookie and session", function() {
                var res =  testObjectUnderTest._getResultValue({
                    Type: "DynamicProxy",
                    ServerCookie: 15
                });

                assert.strictEqual(res._proxyId, 15);
                assert.strictEqual(res._session, testObjectUnderTest._session);
            });

            it("should call the _fillKeysFromMembers of the native object", function() {
                testObjectUnderTest._getResultValue({
                    Type: "DynamicProxy",
                    ServerCookie: 15
                });

                assert(nativeObjProto._fillKeysFromMembers.calledOnce);
            });
        });
    });

    describe("error handling", function() {
        var resultPromise;
        var sessionMock;

        beforeEach(function(){
            sessionMock = {
                _communication: {
                    send: sinon.stub()
                }
            };

            resultPromise = {
                then: sinon.stub()
            };
            sessionMock._communication.send.returns(resultPromise);

            testObjectUnderTest._init(null,sessionMock,null);
        });

        it("should throw the given exception in case the error code is one of general errors",function(){
            var error = new Error("SomeError");
            error.statusCode = -100;
            resultPromise.then.callsArgWith(1,error);

            assert.throws(function(){
                testObjectUnderTest._executeCommand("SomeCommand");
            },/SomeError/);
        });

        it("should throw the given exception in case there is no statusCode",function(){
            var error = new Error("SomeError");
            resultPromise.then.callsArgWith(1,error);

            assert.throws(function(){
                testObjectUnderTest._executeCommand("SomeCommand");
            },/SomeError/);
        });

        it("should translate code of a replay error to correct message",function(){
            var error = new Error("");
            error.statusCode = -111;
            resultPromise.then.callsArgWith(1,error);

            assert.throws(function(){
                testObjectUnderTest._executeCommand("SomeCommand");
            },/ReplayObjectNotFoundException/);
        });

        it("should concat error message passed with the translation of the replay error",function(){
            var error = new Error("some error");
            error.statusCode = -111;
            resultPromise.then.callsArgWith(1,error);

            assert.throws(function(){
                testObjectUnderTest._executeCommand("SomeCommand");
            },/ReplayObjectNotFoundException: some error/);
        });

        it("should convert native types to lean ft types in the error message", function() {
            testObjectUnderTest._init("NativeClass", sessionMock, {
                leanFTType: {
                    technology: "Tech",
                    leanftType: "LeanFtType"
                },
                _toJSON: sinon.stub()
            });

            testObjectUnderTest._parent = new TestObjectBase();

            testObjectUnderTest._parent._init("ParentNativeClass", sessionMock, {
                leanFTType: {
                    technology: "Tech2",
                    leanftType: "ParentLeanFtType"
                },
                _toJSON: sinon.stub()
            });

            var error = new Error("[ NativeClass ], [ ParentNativeClass ] (of class blablabla) aaa");
            error.statusCode = -111;
            resultPromise.then.callsArgWith(1,error);

            assert.throws(function(){
                testObjectUnderTest._executeCommand("SomeCommand");
            },/ReplayObjectNotFoundException: Tech.LeanFtType, Tech2.ParentLeanFtType aaa/);
        });
    });

    describe("snapshot",function(){
        beforeEach(function(){
            sinon.stub(testObjectUnderTest,"_executeCommand");
        });

        it("should execute the command CaptureSnapshotToBase64String and pass the given format",function(){
            testObjectUnderTest.snapshot({format:"bmp"});

            assert(testObjectUnderTest._executeCommand.calledOnce);
            assert.deepEqual(testObjectUnderTest._executeCommand.firstCall.args,["CaptureSnapshotToBase64String","bmp"]);
        });

        it("should default the format to png",function(){
            testObjectUnderTest.snapshot({});

            assert(testObjectUnderTest._executeCommand.calledOnce);
            assert.deepEqual(testObjectUnderTest._executeCommand.firstCall.args,["CaptureSnapshotToBase64String","png"]);
        });

        it("should create default object in case no options is given",function(){
            testObjectUnderTest.snapshot();

            assert(testObjectUnderTest._executeCommand.calledOnce);
            assert.deepEqual(testObjectUnderTest._executeCommand.firstCall.args,["CaptureSnapshotToBase64String","png"]);
        });

        it("should return the result given from the execute command",function(){
            testObjectUnderTest._executeCommand.returns(42);
            var res = testObjectUnderTest.snapshot();

            assert.strictEqual(res,42);
        });
    });

    describe("getVisibleText", function(){
        beforeEach(function(){
            sinon.stub(testObjectUnderTest,"_executeUtilityCommand");
        });

        it("should execute the command GetTestObjectVisibleText with ExecuteTestObjectOcrCommand command type and GetTestObjectVisibleText method name, and pass default rectangle value", function(){
            testObjectUnderTest.getVisibleText();

            assert(testObjectUnderTest._executeUtilityCommand.calledOnce);
            assert.deepEqual(testObjectUnderTest._executeUtilityCommand.firstCall.args, ["ExecuteTestObjectOcrCommand", "GetTestObjectVisibleText", -1, -1, -1, -1]);
        });

        it("should execute the command GetTestObjectVisibleText with the given rectangle values", function(){
            testObjectUnderTest.getVisibleText({x:10,y:20,width:30,height:40});

            assert(testObjectUnderTest._executeUtilityCommand.calledOnce);
            assert.deepEqual(testObjectUnderTest._executeUtilityCommand.firstCall.args, ["ExecuteTestObjectOcrCommand", "GetTestObjectVisibleText", 10, 20, 40, 60]);
        });
    });

    describe("getTextLocations", function() {
        beforeEach(function () {
            sinon.stub(testObjectUnderTest, "_executeUtilityCommand");
            var resultPromise = {
                then: function(cb){return cb(null);}
            };
            testObjectUnderTest._executeUtilityCommand.returns(resultPromise);
        });

        it("should execute the command GetTestObjectTextLocations with ExecuteTestObjectOcrCommand command type and GetTestObjectTextLocations method name, Text as text to search for, and default rectangle parameter values", function(){
            var result = testObjectUnderTest.getTextLocations("Text");

            assert(testObjectUnderTest._executeUtilityCommand.calledOnce);
            assert.deepEqual(testObjectUnderTest._executeUtilityCommand.firstCall.args, ["ExecuteTestObjectOcrCommand", "GetTestObjectTextLocations", "Text", -1, -1, -1, -1]);
            assert.equal(result, null);
        });

        it("should execute the command GetTestObjectTextLocations with the given rectangle values", function(){
            var result = testObjectUnderTest.getTextLocations("Text", {x:10,y:20,width:30,height:40});

            assert(testObjectUnderTest._executeUtilityCommand.calledOnce);
            assert.deepEqual(testObjectUnderTest._executeUtilityCommand.firstCall.args, ["ExecuteTestObjectOcrCommand", "GetTestObjectTextLocations", "Text", 10, 20, 40, 60]);
            assert.equal(result, null);
        });

        it("should throw exception if text argument is not passed", function(){
            assert.throws(function(){
                testObjectUnderTest.getTextLocations();
            });
        })
    });


    describe("verifyImageExists", function() {
        beforeEach(function () {
            sinon.stub(testObjectUnderTest, "_executeUtilityCommand");
            testObjectUnderTest.notifyWithEvents =  function(func) {
                return func.call(this);
            };

            var resultPromise = {
                then: function(cb){return cb(null);}
            };
            testObjectUnderTest._executeUtilityCommand.returns(resultPromise);
        });

        it("should execute the command FindBitmapInTestObject with ExecuteTestObjectImageCommand command type and FindBitmapInTestObject method name, Base64String as imageToFind parameter and empty string as last parameter", function(){
            testObjectUnderTest.verifyImageExists("Base64String");

            assert(testObjectUnderTest._executeUtilityCommand.calledOnce);
            assert.deepEqual(testObjectUnderTest._executeUtilityCommand.firstCall.args.splice(0,4), ["ExecuteTestObjectImageCommand", "FindBitmapInTestObject", "Base64String", ""]);
        });

        it("should execute the command FindBitmapInTestObject and return the point if the similarity argument passed is less than the actual similarity returned", function(){
            testObjectUnderTest._executeUtilityCommand.restore();
            sinon.stub(testObjectUnderTest, "_executeUtilityCommand");
            var resultPromise = {
                then: function(cb) {
                    return cb({
                        actualSimilarity: 10,
                        point: {
                            x: 20,
                            y: 30
                        }
                    });
                }
            };
            testObjectUnderTest._executeUtilityCommand.returns(resultPromise);

            var resultPoint = testObjectUnderTest.verifyImageExists("Base64String", 5);

            assert(testObjectUnderTest._executeUtilityCommand.calledOnce);
            assert.deepEqual(resultPoint, {x:20, y:30});
        });

        it("should execute the command FindBitmapInTestObject and return the point if the similarity argument passed as numeric string is less than the actual similarity returned", function(){
            testObjectUnderTest._executeUtilityCommand.restore();
            sinon.stub(testObjectUnderTest, "_executeUtilityCommand");
            var resultPromise = {
                then: function(cb) {
                    return cb({
                        actualSimilarity: "10",
                        point: {
                            x: 20,
                            y: 30
                        }
                    });
                }
            };
            testObjectUnderTest._executeUtilityCommand.returns(resultPromise);

            var resultPoint = testObjectUnderTest.verifyImageExists("Base64String", 5);

            assert(testObjectUnderTest._executeUtilityCommand.calledOnce);
            assert.deepEqual(resultPoint, {x:20, y:30});
        });

        it("should execute the command FindBitmapInTestObject and return null if the similarity argument passed is larger than the actual similarity returned", function(){
            testObjectUnderTest._executeUtilityCommand.restore();
            sinon.stub(testObjectUnderTest, "_executeUtilityCommand");
            var resultPromise = {
                then: function(cb) {
                    return cb({
                        actualSimilarity: 5,
                        point: {
                            x: 20,
                            y: 30
                        }
                    });
                }
            };
            testObjectUnderTest._executeUtilityCommand.returns(resultPromise);

            var resultPoint = testObjectUnderTest.verifyImageExists("Base64String", 10);

            assert(testObjectUnderTest._executeUtilityCommand.calledOnce);
            assert.deepEqual(resultPoint, null);
        });

        it("should throw exception if imageToFind argument is not passed", function(){
            assert.throws(function(){
                testObjectUnderTest.verifyImageExists();
            });
        });

        it("should throw exception if similarity is less than 0", function(){
            assert.throws(function(){
                testObjectUnderTest.verifyImageExists("Base64String", -1);
            });
        });

        it("should throw exception if similarity is greater than 100", function(){
            assert.throws(function(){
                testObjectUnderTest.verifyImageExists("Base64String", 200);
            });
        });

        it("should throw exception if similarity passed as string is not a numeric string", function(){
            assert.throws(function(){
                testObjectUnderTest.verifyImageExists("Base64String", "10a");
            });
        });
    });

    describe("verifyImageMatch", function() {
        beforeEach(function () {
            sinon.stub(testObjectUnderTest, "_executeUtilityCommand");
            testObjectUnderTest.notifyWithEvents = function(func) {
                return func.call(this);
            };
            var resultPromise = {
                then: function(cb){return cb(null);}
            };
            testObjectUnderTest._executeUtilityCommand.returns(resultPromise);
        });

        it("should execute the command CompareTestObjectWithBitmap with ExecuteTestObjectImageCommand command type and FindBitmapInTestObject method name, Base64String1 as expectedImage parameter and Base64String2 as maskAreaImage parameter", function(){
            testObjectUnderTest.verifyImageMatch("Base64String1", "Base64String2");

            assert(testObjectUnderTest._executeUtilityCommand.calledOnce);
            assert.deepEqual(testObjectUnderTest._executeUtilityCommand.firstCall.args.slice(0,6), ["ExecuteTestObjectImageCommand", "CompareTestObjectWithBitmap", "Base64String1", "Base64String2", 0, 0]);
        });

        it("should throw exception if expectedImage argument is not passed", function(){
            assert.throws(function(){
                testObjectUnderTest.verifyImageMatch();
            });
        });

        it("should throw exception if maskAreaImage argument is not passed", function(){
            assert.throws(function(){
                testObjectUnderTest.verifyImageMatch("Base64String1");
            });
        });

        it("should throw exception if pixelTolerance is less than 0", function(){
            assert.throws(function(){
                testObjectUnderTest.verifyImageMatch("Base64String1", "Base64String2", -1);
            });
        });

        it("should throw exception if pixelTolerance is greater than 100", function(){
            assert.throws(function(){
                testObjectUnderTest.verifyImageMatch("Base64String1", "Base64String2", 200);
            });
        });

        it("should throw exception if rgbTolerance is less than 0", function(){
            assert.throws(function(){
                testObjectUnderTest.verifyImageMatch("Base64String1", "Base64String2", 10, -1);
            });
        });

        it("should throw exception if pixelTolerance is greater than 100", function(){
            assert.throws(function(){
                testObjectUnderTest.verifyImageMatch("Base64String1", "Base64String2", 10, 200);
            });
        });

        it("should execute the command CompareTestObjectWithBitmap and return true when the communication result contains true in imagesMatch", function(){
            testObjectUnderTest._executeUtilityCommand.restore();
            sinon.stub(testObjectUnderTest, "_executeUtilityCommand");
            var resultPromise = {
                then: function(cb) {
                    return cb({
                        imagesMatch: true,
                        base64EncodedDiffImage: "Base64String3"
                    });
                }
            };
            testObjectUnderTest._executeUtilityCommand.returns(resultPromise);

            var resultValue = testObjectUnderTest.verifyImageMatch("Base64String1", "Base64String2");

            assert(testObjectUnderTest._executeUtilityCommand.calledOnce);
            assert.equal(resultValue, true);
        });

    });

    describe("description", function () {
        it("should return the value of the _description member", function () {
            testObjectUnderTest._description = "someDescription";
            assert.strictEqual(testObjectUnderTest.description(), "someDescription");
        });
    });

    describe("parent", function () {
        it("should return the value of the _parent member", function () {
            testObjectUnderTest._parent = "someParent";
            assert.strictEqual(testObjectUnderTest.parent(), "someParent");
        });
    });
});
// SIG // Begin signature block
// SIG // MIIdqgYJKoZIhvcNAQcCoIIdmzCCHZcCAQExDzANBglg
// SIG // hkgBZQMEAgEFADB3BgorBgEEAYI3AgEEoGkwZzAyBgor
// SIG // BgEEAYI3AgEeMCQCAQEEEBDgyQbOONQRoqMAEEvTUJAC
// SIG // AQACAQACAQACAQACAQAwMTANBglghkgBZQMEAgEFAAQg
// SIG // G7x45COtIMjqLoIEy+u37KqT4rnA7yfpbt0p1oawcSKg
// SIG // ghi2MIID7jCCA1egAwIBAgIQfpPr+3zGTlnqS5p31Ab8
// SIG // OzANBgkqhkiG9w0BAQUFADCBizELMAkGA1UEBhMCWkEx
// SIG // FTATBgNVBAgTDFdlc3Rlcm4gQ2FwZTEUMBIGA1UEBxML
// SIG // RHVyYmFudmlsbGUxDzANBgNVBAoTBlRoYXd0ZTEdMBsG
// SIG // A1UECxMUVGhhd3RlIENlcnRpZmljYXRpb24xHzAdBgNV
// SIG // BAMTFlRoYXd0ZSBUaW1lc3RhbXBpbmcgQ0EwHhcNMTIx
// SIG // MjIxMDAwMDAwWhcNMjAxMjMwMjM1OTU5WjBeMQswCQYD
// SIG // VQQGEwJVUzEdMBsGA1UEChMUU3ltYW50ZWMgQ29ycG9y
// SIG // YXRpb24xMDAuBgNVBAMTJ1N5bWFudGVjIFRpbWUgU3Rh
// SIG // bXBpbmcgU2VydmljZXMgQ0EgLSBHMjCCASIwDQYJKoZI
// SIG // hvcNAQEBBQADggEPADCCAQoCggEBALGss0lUS5ccEgrY
// SIG // JXmRIlcqb9y4JsRDc2vCvy5QWvsUwnaOQwElQ7Sh4kX0
// SIG // 6Ld7w3TMIte0lAAC903tv7S3RCRrzV9FO9FEzkMScxeC
// SIG // i2m0K8uZHqxyGyZNcR+xMd37UWECU6aq9UksBXhFpS+J
// SIG // zueZ5/6M4lc/PcaS3Er4ezPkeQr78HWIQZz/xQNRmarX
// SIG // bJ+TaYdlKYOFwmAUxMjJOxTawIHwHw103pIiq8r3+3R8
// SIG // J+b3Sht/p8OeLa6K6qbmqicWfWH3mHERvOJQoUvlXfrl
// SIG // Dqcsn6plINPYlujIfKVOSET/GeJEB5IL12iEgF1qeGRF
// SIG // zWBGflTBE3zFefHJwXECAwEAAaOB+jCB9zAdBgNVHQ4E
// SIG // FgQUX5r1blzMzHSa1N197z/b7EyALt0wMgYIKwYBBQUH
// SIG // AQEEJjAkMCIGCCsGAQUFBzABhhZodHRwOi8vb2NzcC50
// SIG // aGF3dGUuY29tMBIGA1UdEwEB/wQIMAYBAf8CAQAwPwYD
// SIG // VR0fBDgwNjA0oDKgMIYuaHR0cDovL2NybC50aGF3dGUu
// SIG // Y29tL1RoYXd0ZVRpbWVzdGFtcGluZ0NBLmNybDATBgNV
// SIG // HSUEDDAKBggrBgEFBQcDCDAOBgNVHQ8BAf8EBAMCAQYw
// SIG // KAYDVR0RBCEwH6QdMBsxGTAXBgNVBAMTEFRpbWVTdGFt
// SIG // cC0yMDQ4LTEwDQYJKoZIhvcNAQEFBQADgYEAAwmbj3nv
// SIG // f1kwqu9otfrjCR27T4IGXTdfplKfFo3qHJIJRG71betY
// SIG // fDDo+WmNI3MLEm9Hqa45EfgqsZuwGsOO61mWAK3ODE2y
// SIG // 0DGmCFwqevzieh1XTKhlGOl5QGIllm7HxzdqgyEIjkHq
// SIG // 3dlXPx13SYcqFgZepjhqIhKjURmDfrYwggSjMIIDi6AD
// SIG // AgECAhAOz/Q4yP6/NW4E2GqYGxpQMA0GCSqGSIb3DQEB
// SIG // BQUAMF4xCzAJBgNVBAYTAlVTMR0wGwYDVQQKExRTeW1h
// SIG // bnRlYyBDb3Jwb3JhdGlvbjEwMC4GA1UEAxMnU3ltYW50
// SIG // ZWMgVGltZSBTdGFtcGluZyBTZXJ2aWNlcyBDQSAtIEcy
// SIG // MB4XDTEyMTAxODAwMDAwMFoXDTIwMTIyOTIzNTk1OVow
// SIG // YjELMAkGA1UEBhMCVVMxHTAbBgNVBAoTFFN5bWFudGVj
// SIG // IENvcnBvcmF0aW9uMTQwMgYDVQQDEytTeW1hbnRlYyBU
// SIG // aW1lIFN0YW1waW5nIFNlcnZpY2VzIFNpZ25lciAtIEc0
// SIG // MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA
// SIG // omMLOUS4uyOnREm7Dv+h8GEKU5OwmNutLA9KxW7/hjxT
// SIG // VQ8VzgQ/K/2plpbZvmF5C1vJTIZ25eBDSyKV7sIrQ8Gf
// SIG // 2Gi0jkBP7oU4uRHFI/JkWPAVMm9OV6GuiKQC1yoezUvh
// SIG // 3WPVF4kyW7BemVqonShQDhfultthO0VRHc8SVguSR/yr
// SIG // rvZmPUescHLnkudfzRC5xINklBm9JYDh6NIipdC6Anqh
// SIG // d5NbZcPuF3S8QYYq3AhMjJKMkS2ed0QfaNaodHfbDlsy
// SIG // i1aLM73ZY8hJnTrFxeozC9Lxoxv0i77Zs1eLO94Ep3oi
// SIG // siSuLsdwxb5OgyYI+wu9qU+ZCOEQKHKqzQIDAQABo4IB
// SIG // VzCCAVMwDAYDVR0TAQH/BAIwADAWBgNVHSUBAf8EDDAK
// SIG // BggrBgEFBQcDCDAOBgNVHQ8BAf8EBAMCB4AwcwYIKwYB
// SIG // BQUHAQEEZzBlMCoGCCsGAQUFBzABhh5odHRwOi8vdHMt
// SIG // b2NzcC53cy5zeW1hbnRlYy5jb20wNwYIKwYBBQUHMAKG
// SIG // K2h0dHA6Ly90cy1haWEud3Muc3ltYW50ZWMuY29tL3Rz
// SIG // cy1jYS1nMi5jZXIwPAYDVR0fBDUwMzAxoC+gLYYraHR0
// SIG // cDovL3RzLWNybC53cy5zeW1hbnRlYy5jb20vdHNzLWNh
// SIG // LWcyLmNybDAoBgNVHREEITAfpB0wGzEZMBcGA1UEAxMQ
// SIG // VGltZVN0YW1wLTIwNDgtMjAdBgNVHQ4EFgQURsZpow5K
// SIG // FB7VTNpSYxc/Xja8DeYwHwYDVR0jBBgwFoAUX5r1blzM
// SIG // zHSa1N197z/b7EyALt0wDQYJKoZIhvcNAQEFBQADggEB
// SIG // AHg7tJEqAEzwj2IwN3ijhCcHbxiy3iXcoNSUA6qGTiWf
// SIG // mkADHN3O43nLIWgG2rYytG2/9CwmYzPkSWRtDebDZw73
// SIG // BaQ1bHyJFsbpst+y6d0gxnEPzZV03LZc3r03H0N45ni1
// SIG // zSgEIKOq8UvEiCmRDoDREfzdXHZuT14ORUZBbg2w6jia
// SIG // sTraCXEQ/Bx5tIB7rGn0/Zy2DBYr8X9bCT2bW+IWyhOB
// SIG // bQAuOA2oKY8s4bL0WqkBrxWcLC9JG9siu8P+eJRRw4ax
// SIG // gohd8D20UaF5Mysue7ncIAkTcetqGVvP6KUwVyyJST+5
// SIG // z3/Jvz4iaGNTmr1pdKzFHTx/kuDDvBzYBHUwggUeMIIE
// SIG // BqADAgECAhBBOdHLco8U0T0ppjKaGuk8MA0GCSqGSIb3
// SIG // DQEBCwUAMH8xCzAJBgNVBAYTAlVTMR0wGwYDVQQKExRT
// SIG // eW1hbnRlYyBDb3Jwb3JhdGlvbjEfMB0GA1UECxMWU3lt
// SIG // YW50ZWMgVHJ1c3QgTmV0d29yazEwMC4GA1UEAxMnU3lt
// SIG // YW50ZWMgQ2xhc3MgMyBTSEEyNTYgQ29kZSBTaWduaW5n
// SIG // IENBMB4XDTE2MDMyMjAwMDAwMFoXDTE3MDMyMzIzNTk1
// SIG // OVowgaQxCzAJBgNVBAYTAlVTMRMwEQYDVQQIDApDYWxp
// SIG // Zm9ybmlhMRIwEAYDVQQHDAlQYWxvIEFsdG8xKzApBgNV
// SIG // BAoMIkhld2xldHQgUGFja2FyZCBFbnRlcnByaXNlIENv
// SIG // bXBhbnkxEjAQBgNVBAsMCUNvZGUgU2lnbjErMCkGA1UE
// SIG // AwwiSGV3bGV0dCBQYWNrYXJkIEVudGVycHJpc2UgQ29t
// SIG // cGFueTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoC
// SIG // ggEBAMGgAXZcNuvF8MzEBQ9daA+60G+7667OIG2+jYQP
// SIG // NjCrcfmj+1/tNB/NRPBUAuITQCmENam4I7imHQH7Lg2O
// SIG // ilNADlkdTg2sQyvYh/vIKiLeKK1vgFOwXuqcG7Ls6xsL
// SIG // dJFhsMsq/7cSXJdWNN58wij65A0qXM3/uwcEVuayJ0XH
// SIG // KsOJoFVQD1VNBS2Y64bcAVUXvgWnmVbH/mP63s7pdjKo
// SIG // NeVOnJy8axVByDRm75M83uOQqhLhGhBxmJnWdTm1sl7L
// SIG // Drc3gZq8dPTADSUwGtkXY67vgZO4BkLxHzelYu2OMUoQ
// SIG // 8JlFDd0usxwKseyg0ZWihFUumC0kCzuv0fq1qhUCAwEA
// SIG // AaOCAW4wggFqMAkGA1UdEwQCMAAwDgYDVR0PAQH/BAQD
// SIG // AgeAMBMGA1UdJQQMMAoGCCsGAQUFBwMDMGYGA1UdIARf
// SIG // MF0wWwYLYIZIAYb4RQEHFwMwTDAjBggrBgEFBQcCARYX
// SIG // aHR0cHM6Ly9kLnN5bWNiLmNvbS9jcHMwJQYIKwYBBQUH
// SIG // AgIwGRoXaHR0cHM6Ly9kLnN5bWNiLmNvbS9ycGEwHwYD
// SIG // VR0jBBgwFoAUljtT8Hkzl699g+8uK8zKt4YecmYwKwYD
// SIG // VR0fBCQwIjAgoB6gHIYaaHR0cDovL3N2LnN5bWNiLmNv
// SIG // bS9zdi5jcmwwVwYIKwYBBQUHAQEESzBJMB8GCCsGAQUF
// SIG // BzABhhNodHRwOi8vc3Yuc3ltY2QuY29tMCYGCCsGAQUF
// SIG // BzAChhpodHRwOi8vc3Yuc3ltY2IuY29tL3N2LmNydDAR
// SIG // BglghkgBhvhCAQEEBAMCBBAwFgYKKwYBBAGCNwIBGwQI
// SIG // MAYBAQABAf8wDQYJKoZIhvcNAQELBQADggEBAIVbsb1l
// SIG // QffQZ4Ry6IkXNI1/mSIscM5U4vosrSwOou3nypo2QHpl
// SIG // C0BoUcSlavhAQ8cA5kwlxN4H+zb7bnB2lrvxCIjDT2/+
// SIG // uwWDLb1Z3GBV/Dneyr6uSKE9aUjKE7S5v7WabLcCPj1v
// SIG // 1/p6wNkPR+3czu839mJbuVOR8okTWwjZjZgs9ommE+53
// SIG // fE1cxdqzz+hD+Dukbos3+PdYaaVA2/lHoFWVlj1B9oig
// SIG // Bsv1ZbagBuEVtF1fb8uY8tDWnd4QDKE7vcq52tm9L7Xz
// SIG // B3SIyc+UTUi5BECXpqXsAHhQ9So5frKvWsELbOst/lOD
// SIG // zzMTGlOlyW6R3mc9zILt2m5Vdg4wggVZMIIEQaADAgEC
// SIG // AhA9eNf5dklgsmF99PAeyoYqMA0GCSqGSIb3DQEBCwUA
// SIG // MIHKMQswCQYDVQQGEwJVUzEXMBUGA1UEChMOVmVyaVNp
// SIG // Z24sIEluYy4xHzAdBgNVBAsTFlZlcmlTaWduIFRydXN0
// SIG // IE5ldHdvcmsxOjA4BgNVBAsTMShjKSAyMDA2IFZlcmlT
// SIG // aWduLCBJbmMuIC0gRm9yIGF1dGhvcml6ZWQgdXNlIG9u
// SIG // bHkxRTBDBgNVBAMTPFZlcmlTaWduIENsYXNzIDMgUHVi
// SIG // bGljIFByaW1hcnkgQ2VydGlmaWNhdGlvbiBBdXRob3Jp
// SIG // dHkgLSBHNTAeFw0xMzEyMTAwMDAwMDBaFw0yMzEyMDky
// SIG // MzU5NTlaMH8xCzAJBgNVBAYTAlVTMR0wGwYDVQQKExRT
// SIG // eW1hbnRlYyBDb3Jwb3JhdGlvbjEfMB0GA1UECxMWU3lt
// SIG // YW50ZWMgVHJ1c3QgTmV0d29yazEwMC4GA1UEAxMnU3lt
// SIG // YW50ZWMgQ2xhc3MgMyBTSEEyNTYgQ29kZSBTaWduaW5n
// SIG // IENBMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKC
// SIG // AQEAl4MeABavLLHSCMTXaJNRYB5x9uJHtNtYTSNiarS/
// SIG // WhtR96MNGHdou9g2qy8hUNqe8+dfJ04LwpfICXCTqdpc
// SIG // DU6kDZGgtOwUzpFyVC7Oo9tE6VIbP0E8ykrkqsDoOatT
// SIG // zCHQzM9/m+bCzFhqghXuPTbPHMWXBySO8Xu+MS09bty1
// SIG // mUKfS2GVXxxw7hd924vlYYl4x2gbrxF4GpiuxFVHU9mz
// SIG // MtahDkZAxZeSitFTp5lbhTVX0+qTYmEgCscwdyQRTWKD
// SIG // trp7aIIx7mXK3/nVjbI13Iwrb2pyXGCEnPIMlF7AVlIA
// SIG // SMzT+KV93i/XE+Q4qITVRrgThsIbnepaON2b2wIDAQAB
// SIG // o4IBgzCCAX8wLwYIKwYBBQUHAQEEIzAhMB8GCCsGAQUF
// SIG // BzABhhNodHRwOi8vczIuc3ltY2IuY29tMBIGA1UdEwEB
// SIG // /wQIMAYBAf8CAQAwbAYDVR0gBGUwYzBhBgtghkgBhvhF
// SIG // AQcXAzBSMCYGCCsGAQUFBwIBFhpodHRwOi8vd3d3LnN5
// SIG // bWF1dGguY29tL2NwczAoBggrBgEFBQcCAjAcGhpodHRw
// SIG // Oi8vd3d3LnN5bWF1dGguY29tL3JwYTAwBgNVHR8EKTAn
// SIG // MCWgI6Ahhh9odHRwOi8vczEuc3ltY2IuY29tL3BjYTMt
// SIG // ZzUuY3JsMB0GA1UdJQQWMBQGCCsGAQUFBwMCBggrBgEF
// SIG // BQcDAzAOBgNVHQ8BAf8EBAMCAQYwKQYDVR0RBCIwIKQe
// SIG // MBwxGjAYBgNVBAMTEVN5bWFudGVjUEtJLTEtNTY3MB0G
// SIG // A1UdDgQWBBSWO1PweTOXr32D7y4rzMq3hh5yZjAfBgNV
// SIG // HSMEGDAWgBR/02Wnwt3su/AwCfNDOfoCrzMxMzANBgkq
// SIG // hkiG9w0BAQsFAAOCAQEAE4UaHmmpN/egvaSvfh1hU/6d
// SIG // jF4MpnUeeBcj3f3sGgNVOftxlcdlWqeOMNJEWmHbcG/a
// SIG // IQXCLnO6SfHRk/5dyc1eA+CJnj90Htf3OIup1s+7NS8z
// SIG // WKiSVtHITTuC5nmEFvwosLFH8x2iPu6H2aZ/pFalP62E
// SIG // LinefLyoqqM9BAHqupOiDlAiKRdMh+Q6EV/WpCWJmwVr
// SIG // L7TJAUwnewusGQUioGAVP9rJ+01Mj/tyZ3f9J5THujUO
// SIG // iEn+jf0or0oSvQ2zlwXeRAwV+jYrA9zBUAHxoRFdFOXi
// SIG // vSdLVL4rhF4PpsN0BQrvl8OJIrEfd/O9zUPU8UypP7WL
// SIG // hK9k8tAUITCCBZowggOCoAMCAQICCmEZk+QAAAAAABww
// SIG // DQYJKoZIhvcNAQEFBQAwfzELMAkGA1UEBhMCVVMxEzAR
// SIG // BgNVBAgTCldhc2hpbmd0b24xEDAOBgNVBAcTB1JlZG1v
// SIG // bmQxHjAcBgNVBAoTFU1pY3Jvc29mdCBDb3Jwb3JhdGlv
// SIG // bjEpMCcGA1UEAxMgTWljcm9zb2Z0IENvZGUgVmVyaWZp
// SIG // Y2F0aW9uIFJvb3QwHhcNMTEwMjIyMTkyNTE3WhcNMjEw
// SIG // MjIyMTkzNTE3WjCByjELMAkGA1UEBhMCVVMxFzAVBgNV
// SIG // BAoTDlZlcmlTaWduLCBJbmMuMR8wHQYDVQQLExZWZXJp
// SIG // U2lnbiBUcnVzdCBOZXR3b3JrMTowOAYDVQQLEzEoYykg
// SIG // MjAwNiBWZXJpU2lnbiwgSW5jLiAtIEZvciBhdXRob3Jp
// SIG // emVkIHVzZSBvbmx5MUUwQwYDVQQDEzxWZXJpU2lnbiBD
// SIG // bGFzcyAzIFB1YmxpYyBQcmltYXJ5IENlcnRpZmljYXRp
// SIG // b24gQXV0aG9yaXR5IC0gRzUwggEiMA0GCSqGSIb3DQEB
// SIG // AQUAA4IBDwAwggEKAoIBAQCvJAgIKXo1nmAMqudLO07c
// SIG // fLw8RRy7K+D+KQL5VwijZIUVJ/XxrcgxiV0i6CqqpkKz
// SIG // j/i5Vbext0uz/o9+B1fs70PbZmIVYc9gDaTY3vjgw2II
// SIG // PVQT60nKWVSFJuUrjxuf6/WhkcIzSdhDY2pSS9KP6HBR
// SIG // TdGJaXvHcPaz3BJ023tdS1bTlr8Vd6Gw9KIl8q8ckmcY
// SIG // 5fQGBO+QueQA5N06tRn/Arr0PO7gi+s3i+z016zy9vA9
// SIG // r911kTMZHRxAy3QkGSGT2RT+rCpSx4/VBEnkjWNHiDxp
// SIG // g8v+R70rfk/Fla4OndTRQ8Bnc+MUCH7lP59zuDMKz10/
// SIG // NIeWiu5T6CUVAgMBAAGjgcswgcgwEQYDVR0gBAowCDAG
// SIG // BgRVHSAAMA8GA1UdEwEB/wQFMAMBAf8wCwYDVR0PBAQD
// SIG // AgGGMB0GA1UdDgQWBBR/02Wnwt3su/AwCfNDOfoCrzMx
// SIG // MzAfBgNVHSMEGDAWgBRi+wohW39DbhHaCVRQa/XSlnHx
// SIG // njBVBgNVHR8ETjBMMEqgSKBGhkRodHRwOi8vY3JsLm1p
// SIG // Y3Jvc29mdC5jb20vcGtpL2NybC9wcm9kdWN0cy9NaWNy
// SIG // b3NvZnRDb2RlVmVyaWZSb290LmNybDANBgkqhkiG9w0B
// SIG // AQUFAAOCAgEAgSqCFow0ZyvlA+s0e4yio1CK9FWG8R6M
// SIG // jq597gMZznKVGEitYhH9IP0/RwYBWuLgb4wVLE48alBs
// SIG // Czajz3oNnEK8XPgZ1WDjaebiI0FnjGiDdiuPk6MqtX++
// SIG // WfupybImj8qi84IbmD6RlSeXhmHuW10Ha82GqOJlgKji
// SIG // FeKyviMFaroM80eTTaykjAd5OcBhEjoFDYmj7J9XiYT7
// SIG // 7Mp8R2YUkdi2Dxld5rhKrLxHyHFDluYyIKXcd4b9POOL
// SIG // cdt7mwP8tx0yZOsWUqBDo/ourVmSTnzH8jNCSDhROnw4
// SIG // xxskIihAHhpGHxfbGPfwJzVsuGPZzblkXSulXu/GKbTy
// SIG // x/ghzAS6V/0BtqvGZ/nn05l/9PUi+nL1/f86HEI6ofmA
// SIG // GKXujRzUZp5FAf6q7v/7F48w9/HNKcWd7LXVSQA9hbjL
// SIG // u5M6J2pJwDCuZsn3Iygydvmkg1bISM5alqqgzAzEf7SO
// SIG // l69t41Qnw5+GwNbkcwiXBdvQVGJeA0jC1Z9/p2aM0J2w
// SIG // T9TTmF9Lesl/silS0BKAxw9Uth5nzcagbBEDhNNIdecq
// SIG // /rA7bgo6pmt2mQWj8XdoYTMURwb8U39SvZIUXEokameM
// SIG // r42QqtD2eSEbkyZ8w84evYg4kq5FxhlqSVCzBfiuWTeK
// SIG // aiUDlLFZgVDouoOAtyM19Ha5Zx1ZGK0gjZQxggRMMIIE
// SIG // SAIBATCBkzB/MQswCQYDVQQGEwJVUzEdMBsGA1UEChMU
// SIG // U3ltYW50ZWMgQ29ycG9yYXRpb24xHzAdBgNVBAsTFlN5
// SIG // bWFudGVjIFRydXN0IE5ldHdvcmsxMDAuBgNVBAMTJ1N5
// SIG // bWFudGVjIENsYXNzIDMgU0hBMjU2IENvZGUgU2lnbmlu
// SIG // ZyBDQQIQQTnRy3KPFNE9KaYymhrpPDANBglghkgBZQME
// SIG // AgEFAKB8MBAGCisGAQQBgjcCAQwxAjAAMBkGCSqGSIb3
// SIG // DQEJAzEMBgorBgEEAYI3AgEEMBwGCisGAQQBgjcCAQsx
// SIG // DjAMBgorBgEEAYI3AgEVMC8GCSqGSIb3DQEJBDEiBCBK
// SIG // Hy93zagQyj3k/iuB3Yl2Nm5fjuhTNZzbBih1YDlSxTAN
// SIG // BgkqhkiG9w0BAQEFAASCAQCX/Ytr/4iGIfH4Tkmmn5DD
// SIG // HEGnR16OvcqXdxWtPFDFgP30YnNiTECC0Gu8yGnXoc5M
// SIG // qE8N6R+HmpCy/UDk9vkXBS9swvLKRkNmbZYG2ebZDPk3
// SIG // ric5PnSA4M3gjt32nZTciXUJoXnnmDn2zRLpH+yAmaEg
// SIG // AioIRNnzUydYxgADXMkRimOfVorr1LenW1MLpTm/yd++
// SIG // kmMpq3goQSw9v7AbnL89hHI/HHTOVp/jipPPHGhRlQ0s
// SIG // zv1u6gJNJJ2qL/VDWkzXXgx/VGVDe6U9Nasl8/NhIFY8
// SIG // 73D8jCejOjEM2Zc1MQYCo4+yho422Da75/C+vNCsgYjb
// SIG // dIHismKx3pFpoYICCzCCAgcGCSqGSIb3DQEJBjGCAfgw
// SIG // ggH0AgEBMHIwXjELMAkGA1UEBhMCVVMxHTAbBgNVBAoT
// SIG // FFN5bWFudGVjIENvcnBvcmF0aW9uMTAwLgYDVQQDEydT
// SIG // eW1hbnRlYyBUaW1lIFN0YW1waW5nIFNlcnZpY2VzIENB
// SIG // IC0gRzICEA7P9DjI/r81bgTYapgbGlAwCQYFKw4DAhoF
// SIG // AKBdMBgGCSqGSIb3DQEJAzELBgkqhkiG9w0BBwEwHAYJ
// SIG // KoZIhvcNAQkFMQ8XDTE2MDUyNjE0MTY0M1owIwYJKoZI
// SIG // hvcNAQkEMRYEFHE04M+0OesFVuSKm7CqjkkJGNFEMA0G
// SIG // CSqGSIb3DQEBAQUABIIBAGXfhkNblIYbvX1EdW6+sic3
// SIG // peeDqaxkgQ+QozSspnByuVYzvaPc3lxtNN1RXNRX+tST
// SIG // a5gF2qOjO/BPO6fcTUyWNcsMzcmUr0lZXUp0KEJh45cO
// SIG // 1/Z5rm1s3U/IZZ5GbKCFQF086gnjazmyLSdYyrBoSsal
// SIG // O1PwGWSLfPFPWorhvCnoIfeoZoc7Kc8fdKv0Wi29Pyb4
// SIG // H2E+7xXtLZR17OVOJqUq9YczBP87M1UfBvWCUdCc/KB8
// SIG // dlpP2q+FaJdeP5HgJ0O30XbdjQlkFm6pLnkaN5LcoKtt
// SIG // u2Xzivk6zF7Bs4MQQmNfHGu4bhncfXtsMdyexaI0cTiF
// SIG // Gt5hynBXt0E=
// SIG // End signature block
