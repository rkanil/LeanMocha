// (c) Copyright 2015 Hewlett Packard Enterprise Development LP

var fs = require('fs');
var RunUnitNode = require("./run_unit_node.js").RunUnitNode;
var RunUnitNodeBase = require("./run_unit_node_base.js").RunUnitNodeBase;
var RunUnitOperationNode = require("./run_unit_operation_node.js").RunUnitOperationNode;
var ReportUtils = require("./report_utils.js").ReportUtils;
var Enums = require("./enums.js");
var Status = Enums.Status;
var CaptureLevel = Enums.CaptureLevel;
var ReportLevel = Enums.ReportLevel;
var RunUnitNodeType = Enums.RunUnitNodeType;
var LFTCore = require("leanft.sdk.core");
var StringUtils = LFTCore.StringUtils;
var ObjectUtils = LFTCore.ObjectUtils;
var Logger = LFTCore.Logger;
var Const = require("./const.js").Const;
var ReportModel = require("./report_model.js").ReportModel;
var Path = require("path");
var JsonReport = require("./json_report.js").JsonReport;
var nconf = require('nconf');


var DefaultConfig = {
    reportFolder:"RunResults",
    title:"Run Results",
    description:"",
    targetDirectory: ".",
    overrideExisting: true,
    reportLevel: ReportLevel.All,
    snapshotsLevel: CaptureLevel.Off,
};

function ReporterProvider() {
    this._shouldGenerateReport = false;
    this._logger = new Logger("ReporterProvider");
    this._initReportModel();
    if(!global.__LFT_REPORTER__){
        global.__LFT_REPORTER__ = this;
    }
}

ReporterProvider.prototype = {
    _runtimeSettings: null,
    _reportModel: null,
    _logger: null,
    _reportGeneratedPath: null,
    _snapshotFolder: null,
    _reportNodesMap: [],
    _nativeObjectsMap: [],
    _session: null,

    FilterLevelAsString: {
        "Off": 1000,
        "Error": 2000,
        "Warning": 3000,
        "All": 4000,
    },

    NodeLevelAsString: {
        "Failed": 2000,
        "Warning": 3000,
        "Passed": 4000,
    },

    cleanup: function () {
        this._session = null;
    },

    onStart: function() {

    },

    onSuiteStart: function(data) {
        this._openReportLevel(
            {
                name: data.name,
                nodeType: RunUnitNodeType.Suite,
            });
    },

    onSpecStart: function(data) {
        this.startSpec(data.name, "");
    },

    onSuiteDone: function(data) {
        this._closeCurrentReportLevel( RunUnitNodeType.Suite, Status.Passed);
    },

    onSpecDone: function(data) {
        if (data.status === "disabled" || data.status === "pending"){
            this._disableCurrentReportLevel(RunUnitNodeType.Spec);
        }
        if (data.status === "failed"){
            this._closeCurrentReportLevel(RunUnitNodeType.Spec, Status.Failed);
            return;
        }
        this._closeCurrentReportLevel(RunUnitNodeType.Spec, Status.Passed);
    },

    onDone: function() {
        this.generateReport();
    },

    /**
     * Initializes the specified report configuration.
     * @param {Object} [session] Initializes a reporter using the supplied session.
     * @param {Object} [configuration] The configuration to use for the report.
     */
    init: function (session, configuration) {
        this._session = session;
        this._session.onBeforeCommand = this._onBeforeOperation.bind(this);
        this._session.onAfterCommand = this._onAfterOperation.bind(this);
        this._session.onAdditionalDataReceivedCommand = this._onAdditionalDataReceivedOperation.bind(this);
        this._session.onErrorCommand = this._onHandleErrorOperation.bind(this);

        configuration = configuration ? configuration.report || configuration : null;

        this._shouldGenerateReport = false;

        var config = this._initializeSettings(configuration);

        ReporterProvider.prototype._runtimeSettings = ReporterProvider.prototype._runtimeSettings || DefaultConfig;
        var targetDirectory = config.targetDirectory;
        var reportFolder = config.reportFolder;

        if ((targetDirectory !== (ReporterProvider.prototype._runtimeSettings.targetDirectory)) ||
            reportFolder !== (ReporterProvider.prototype._runtimeSettings.reportFolder)) {
            this._initReportModel();
            ReporterProvider.prototype._runtimeSettings._generatedReportPath = null;
        }

        var currGeneratedReportPath = ReporterProvider.prototype._runtimeSettings._generatedReportPath;
        ReporterProvider.prototype._runtimeSettings = config;
        ReporterProvider.prototype._runtimeSettings._generatedReportPath = currGeneratedReportPath;

        this._shouldGenerateReport = true;

        if (!ReporterProvider.prototype._runtimeSettings._generatedReportPath) {
            ReporterProvider.prototype._runtimeSettings._generatedReportPath = this._generateReportFolder();
        }

        this._updateSnapshotSettings();
        this._getEnvironmentInfo();
        this._getMobileServerInfo();
    },

    /**
     * Adds a custom step to the LeanFT with default status "Passed".
     * @param {string} stepName The name of the reported step. This name is the label of the step node in the report.
     * @param {string} description The description of the reported step. The description is displayed in the Details pane of the report.
     * @param {Status} status The status for the step.
     */
    reportEvent: function (stepName, description, status) {
        this._reportEvent(stepName, description, status);
    },

    /**
     * Adds a custom step to the LeanFT including exception details.
     * @param {string} stepName The name of the reported step. This name is the label of the step node in the report.
     * @param {string} description The description of the reported step. The description is displayed in the Details pane of the report.
     * @param {Error} exception The exception that occurred.
     */
    reportErrorEvent: function (stepName, description, exception) {
        this._reportEvent(stepName, description, Status.Failed, null, exception);
    },

    /**
     * Adds a custom step to the LeanFT including exception details and the Base64 image.
     * @param {string} stepName The name of the reported step. This name is the label of the step node in the report.
     * @param {string} description The description of the reported step. The description is displayed in the Details pane of the report.
     * @param {Error} exception The exception that occurred.
     * @param {string} image The Base64 image to use for the step.
     */
    reportErrorEventWithImage: function (stepName, description, error, image) {
        if (!image) {
            this._reportEvent(stepName, description, Status.Failed, null, error);
            return;
        }

        var filePath = Path.join("Snapshots", ReportUtils.generateUUID() + ".png");
        ReportUtils.base64_decode(image, Path.join(ReporterProvider.prototype._runtimeSettings._generatedReportPath, filePath));
        this._reportEvent(stepName, description, Status.Failed, filePath, error);
    },

    /**
     * Starts a new spec level for the LeanFT report.
     * @param {string} specName The name of the spec.  This name is the label of the spec node in the report.
     * @param {string} specDescription The spec description.
     */
    startSpec: function (specName, specDescription) {
        this._openReportLevel(
            {
                name: specName,
                description: specDescription,
                nodeType: RunUnitNodeType.Spec,
            }
        );
    },

    /**
     * Ends the current spec level and optionally sets the status for the spec.
     * @param {Status} [specDescription] The status for the current spec. Default = Passed.
     */
    endSpec: function (status) {
        if (!this._shouldGenerateReport)
            return;

        if (status) {
            ReporterProvider.prototype._reportModel.closeCurrentRunUnitNode(type, status);
            return;
        }
        ReporterProvider.prototype._reportModel.closeCurrentRunUnitNode(type);
    },

    /**
     * The report configuration used for generating the report.
     */
    config: function () {
        return ReporterProvider.prototype._runtimeSettings;
    },

    /**
     * Adds a custom entry to the top section of the LeanFT report.
     * @param {string} fieldName The name of the entry.
     * @param {string} fieldValue The entry value.
     */
    addRunInformation: function (fieldName, fieldValue) {
        if (!this._shouldGenerateReport || !fieldName || !fieldValue)
            return;


        ReporterProvider.prototype._reportModel.addGeneralInfo(fieldName, fieldValue);
    },

    /**
     * Starts a named section in the LeanFT report.
     * @param {string} contextName The section name.
     * @param {string} [contextDescription] The section description. Default=blank.
     */
    startReportingContext: function (contextName, contextDescription) {
        this._openReportLevel(
            {
                name: contextName,
                description: contextDescription,
                nodeType: RunUnitNodeType.Region,
            });
    },

    /**
     * Ends the section in the LeanFT report.
     */
    endReportingContext: function () {
        return this._closeCurrentReportLevel(RunUnitNodeType.Region, Status.Passed);
    },

    /**
     *Generates the LeanFT report.
     */
    generateReport: function () {
        if (!this._shouldGenerateReport) {
            return null;
        }

        try {
            this._closeAllReportLevels();


            var jsonReport = new JsonReport();
            var reportResult = jsonReport.generate(ReportModel.prototype, ReporterProvider.prototype._runtimeSettings);

            var generatedPath = ReporterProvider.prototype._runtimeSettings._generatedReportPath;

            if (!fs.existsSync(generatedPath)) {
                fs.mkdirSync(generatedPath);
            }

            var jsonPath = Path.join(generatedPath, "runresults.json");
            var cssPath = Path.join(generatedPath, "runresults.css");
            var htmlPath = Path.join(generatedPath, "runresults.html");

            var buildReport = require("leanft.report.builder");
            buildReport({jsonPath: jsonPath, cssPath: cssPath, htmlPath: htmlPath}, reportResult);
            return htmlPath;
        } catch (error) {
            this._logger.error("generateReport() failed, error =" + error);
            return null;
        }
    },

    _updateSnapshotSettings: function () {
        if (ReporterProvider.prototype._runtimeSettings.snapshotsLevel === undefined || ReporterProvider.prototype._runtimeSettings.snapshotsLevel === null || !this._session)
            return;

        var settingsData = {
            "UpdateReportSessionSettings": {
                "SnapshotData": ReporterProvider.prototype._runtimeSettings.snapshotsLevel
            }
        };

        // update the runtime engine with current report configuration
        this._session._communication.send("UpdateReportSettingsCommand", settingsData).then(function () {
                this._logger.trace("_updateSnapshotSettings: updated engine with report settings");
            }.bind(this),
            this._handleError.bind(this));
    },

    _addEnvironmentInfo: function (info) {
        ReporterProvider.prototype._reportModel.addEnvironmentInfoData(info);
    },

    _getEnvironmentInfo: function () {
        if (!this._session)
            return;

        // update the runtime engine with current report configuration
        this._session._communication.send("GetEnvironmentInfo", null).then(function (info) {
                this._logger.trace("_getEnvironmentInfo: getting environmentInfo from engine");
                this._addEnvironmentInfo(info);
            }.bind(this),
            function (error) {
                this._logger.error("_getEnvironmentInfo: failed to get environment info from engine, error:" + error);
            });
    },

    _getMobileServerInfo: function () {
        if (!this._session)
            return;

        this._session._communication.send("GetMobileCenterConfiguration", null);
        this._session._promiseManager.rootBranchThen(function (result) {
                var address = result ? result.URI : null;
                if (address) {
                    ReporterProvider.prototype._reportModel.addGeneralInfo("MC Server Address", address);
                }
            },
            function (error) {
                this._logger.error("GetMobileCenterConfiguration: failed to get mobile info from engine, error:" + error);
            }.bind(this));
    },

    _handleError: function (error) {
        this._logger.info("setReporter: failed to update engine with report settings ");
        throw error;
    },

    _initReportModel: function () {
        ReporterProvider.prototype._reportModel = new ReportModel();
    },

    _generateReportFolder: function () {
        if (!fs.existsSync(ReporterProvider.prototype._runtimeSettings.targetDirectory)) {
            throw new Error("Target directory does not exist: " + ReporterProvider.prototype._runtimeSettings.targetDirectory);
        }

        var reportFullPath = Path.join(ReporterProvider.prototype._runtimeSettings.targetDirectory, ReporterProvider.prototype._runtimeSettings.reportFolder);

        if (!ReporterProvider.prototype._runtimeSettings.overrideExisting) {
            // generate new folder
            var i = 1;
            var resultFolder = reportFullPath;

            while (fs.existsSync(resultFolder)) {
                resultFolder = reportFullPath + i;
                i++;
            }
            ReporterProvider.prototype._runtimeSettings._generatedReportPath = Path.resolve(resultFolder);
        }
        else {
            if (fs.existsSync(reportFullPath))
                ReportUtils.deleteFolder(reportFullPath);
            ReporterProvider.prototype._runtimeSettings._generatedReportPath = Path.resolve(reportFullPath);
        }

        fs.mkdirSync(ReporterProvider.prototype._runtimeSettings._generatedReportPath);
        var resourcesFolder = Path.join(ReporterProvider.prototype._runtimeSettings._generatedReportPath, "Resources");
        // create resources folder
        fs.mkdirSync(resourcesFolder);
        // create snapshot folder
        fs.mkdirSync(Path.join(resourcesFolder, "Snapshots"));
        // create user images folder
        fs.mkdirSync(Path.join(resourcesFolder, "User"));

        return ReporterProvider.prototype._runtimeSettings._generatedReportPath;
    },

    _initializeSettings: function (configuration) {
        function parseValue(value) {
            if (typeof(value) === "string")
            {
                var newValue = value.toLowerCase();

                if (newValue === "true" || newValue === "false")
                    return newValue === "true";
            }

            return value;
        }

        configuration = configuration || {};

        // clone
        var config = JSON.parse(JSON.stringify(DefaultConfig));

        ObjectUtils.extend(config, configuration);

        //try to get config file path from ENV
        var configFilePath = nconf.env().get("LEANFT_CONFIG");

        var reportJsonConfig;
        if(configFilePath) {
            var configFile = nconf.file(configFilePath);
            reportJsonConfig = configFile.get('report');
        }

        //for (var key in config) {
        Object.keys(config).map(function(key){
            if (reportJsonConfig ) {
                var value = reportJsonConfig[key];

                // see if json file was set with key
                if (value !== undefined && value !== null) {
                    value = parseValue(value);
                    config[key] = value;
                }
            }

            //see if CMD arg was set with key
            var cmdValue = nconf.argv().get(key);
            if (cmdValue !== undefined && cmdValue !== null) {
                cmdValue = parseValue(cmdValue);
                config[key] = cmdValue;
            }
        });

        return config;
    },

    _reportEvent: function (stepName, description, status, image, error) {
        this._session._promiseManager.rootBranchThen(function () {
            var newStep = new RunUnitNodeBase(
                {
                    name: stepName,
                    description: description,
                    status: status || Status.Passed,
                    exception: error,
                    imageDetails: {path: image, imageType: 'user'},
                    nodeType: RunUnitNodeType.CustomStep
                });

            this._addNodeToReportModel(newStep);
        }.bind(this));
    },

    _reportExpectEvent: function (stepName, hasNot, args, isExpect, error) {
        var notStr = hasNot ? 'not.' : "";
        var expectArguments = [{name: 'expected', value: args[0] ? args[0] :'<p>'+args[0] + '</p>' },{name: 'actual', value: error ? '<p style="color:red;">' + args[1] + '</p>' : args[1]}];
        var validationStep = new RunUnitNodeBase(
            {
                status: error ? Status.Failed : Status.Passed,
                exception: error,
                description : this.buildArgumentsTable(expectArguments),
            });

        if (isExpect){
            validationStep._nodeType = RunUnitNodeType.Expect;
            validationStep._name = 'expect.' + notStr + stepName;
        }
        else{
            validationStep._nodeType = RunUnitNodeType.Verify;
            validationStep._name = 'verify.' + notStr + stepName;
        }
        this._addNodeToReportModel(validationStep);
    },

    _addNodeToReportModel: function (node) {
        var isStructureNode = ReportUtils.isStructureNode(node);
        if (node === null || (!this._shouldGenerateReport && !isStructureNode))
            return;

        if (isStructureNode){
            ReporterProvider.prototype._reportModel.addRunUnitNode(node);
            return;
        }

        var reportLevel = ReporterProvider.prototype._runtimeSettings.reportLevel;
        if (this.NodeLevelAsString[node._status] <= this.FilterLevelAsString[reportLevel]) {
            ReporterProvider.prototype._reportModel.addRunUnitNode(node);
        }
    },


    _openReportLevel: function (node) {
        var runUnitNode = new RunUnitNode(node);
        ReporterProvider.prototype._reportModel.closeContextNodes();
        this._addNodeToReportModel(runUnitNode);
    },

    _closeAllReportLevels: function () {
        if (!this._shouldGenerateReport)
            return;
        ReporterProvider.prototype._reportModel.closeRootRunUnitNode();
    },

    _closeCurrentReportLevel: function (type, status) {
        if (!this._shouldGenerateReport)
            return;
        ReporterProvider.prototype._reportModel.closeCurrentRunUnitNode(type, status);
    },

    _disableCurrentReportLevel: function (type) {
        if (!this._shouldGenerateReport)
            return;
        ReporterProvider.prototype._reportModel.removeCurrentRunUnitNode(type);
    },

    _getLeanFtTypeFromTestObject: function (testObject) {
        if (testObject._nativeClass === "Browser") {
            return "Browser";
        }

        if (testObject._nativeClass === "Device") {
            return "Device";
        }

        if (!testObject._description || !testObject._description.leanFTType)
            return null;

        return testObject._description.leanFTType.leanftType || "";
    },

    _getTechnologyFromTestObject: function (testObject) {
        if (testObject._nativeClass === "Browser") {
            return "Web";
        }

        if (testObject._nativeClass === "Device") {
            return "Mobile";
        }

        if (!testObject._description || !testObject._description.leanFTType)
            return null;

        return testObject._description.leanFTType.technology || "";
    },

    _onBeforeOperation: function (data) {
        try {
            var senderType = data.type;
            var handler = this._specialValueHandler[senderType];

            if (!handler)
                return;

            var node = handler.call(this, data);
            this._reportNodesMap[data.commandId] = node;
        }
        catch (error) {
            this._logger.error("onBeforeOperation - failed. error:" + error);
        }
    },

    _calculateDuration: function (node) {
        return ReportUtils.getCurrentDateTime().getTime() - node._time.getTime();
    },

    _onAfterOperation: function (data) {
        try {
            var result = data.result;
            var senderType = data.type;
            var node = this._reportNodesMap[data.commandId];

            if (!node)
                return;

            // nativeObject scenario
            if (result && result.Result && result.Result.ServerCookie){
                this._nativeObjectsMap[data.result.Result.ServerCookie] = node.cloneNode();
                return;
            }

            var resultHandler = this._specialValueResultHandler[senderType];
            if (resultHandler)
                resultHandler.call(this, node, result.Result);

            node._duration = this._calculateDuration(node);
            this._addNodeToReportModel(node);
        }
        catch (error) {
            this._logger.error("onAfterOperation - failed. error:" + error);
        }
    },

    _getDisplayName: function (testObject, uftDisplayName) {
        if (testObject.DisplayName && !StringUtils.isNullOrWhiteSpace(testObject.DisplayName)) {
            return testObject.DisplayName;
        }

        if (!uftDisplayName) {
            return '[' + this._getLeanFtTypeFromTestObject(testObject) + "]";
        }

        return uftDisplayName;
    },

    _getTestObjectHierarchy: function (testObject) {
        if (!testObject)
            return [];

        var type = this._getTechnologyFromTestObject(testObject) + "." + this._getLeanFtTypeFromTestObject(testObject);
        var parsedDisplayName = this._getDisplayName(testObject);
        return this._getTestObjectHierarchy(testObject._parent).concat([{Type: type, Name: parsedDisplayName}]);
    },

    _addSnapshotForOperation: function (node, base64Image, cb) {
        try {
            var self = this;
            var imageRelativePath = Path.join(Const.SnapshotsFolder, ReportUtils.generateUUID() + ".png");
            var imageFullPath = Path.join(ReporterProvider.prototype._runtimeSettings._generatedReportPath, imageRelativePath);

            ReportUtils.base64_decode(base64Image, imageFullPath, function (error) {
                if (!error) {
                    if (!cb) {
                        node.imageDetails = {path: imageRelativePath, imageType: 'Snapshots'};
                        return;
                    }
                    cb({path: imageFullPath, imageType: 'Snapshots'});
                }
                else {
                    self._logger.error("saving snapshot failed, error = " + error);
                }
            });
        }
        catch (error) {
            this._logger.error("addSnapshotForOperation failed, error = " + error);
        }
    },

    _getSnapshotHighlightArea: function (snapshotData) {
        if ((snapshotData.rectX === null) || (snapshotData.rectY === null) || (snapshotData.topRectX === null) || (snapshotData.topRectY === null))
            return null;

        var offsetX = snapshotData.rectX - snapshotData.topRectX;
        var offsetY = snapshotData.rectY - snapshotData.topRectY;
        var drawWidth = snapshotData.rectWidth;
        var drawHeight = snapshotData.rectHeight;


        return { x: offsetX ,y: offsetY, height: drawHeight, width: drawWidth };
    },

    _onAdditionalDataReceivedOperation: function (data) {
        try {
            var node = this._reportNodesMap[data.commandId];
            var testObject = data.sender;
            var additionalInfo = data.additionalData;

            if (!testObject || !node)
                return;

            var operationAdditionalInfo = additionalInfo ? additionalInfo.AdditionalInfo || additionalInfo : null;
            var eventData = operationAdditionalInfo ? operationAdditionalInfo.ReportEventData : null;

            if (!eventData || !additionalInfo) {
                return;
            }

            var displayNameHierarchy = eventData.DispTestObjectPath;

            if (!Array.isArray(displayNameHierarchy)) {
                var nodeName = eventData.nodeName;
                this._updateHierarchyNames(testObject, [nodeName], node._objectPath);
            }
            else {
                var uftObjectNames = displayNameHierarchy.map(function (objectName) {
                    if (objectName.startsWith('[') && objectName.endsWith(']')){
                        return objectName.substring(2, objectName.length - 2);
                    }
                    return objectName;
                });

                node._nativeType = eventData.Type || node._nativeType;
                this._updateHierarchyNames(testObject, uftObjectNames, node._objectPath);
            }

            node._name = node._objectPath[node._objectPath.length - 1].Name + "." + node._operation;

            if (eventData.SnapshotBitmapRef) {
                this._addSnapshotForOperation(node, eventData.SnapshotBitmapRef);

                var snapshotData = {
                    rectX: eventData.SnapshotHighlightRectX,
                    rectY: eventData.SnapshotHighlightRectY,
                    topRectX: eventData.abs_x,
                    topRectY: eventData.abs_y,
                    rectWidth: eventData.SnapshotHighlightRectWidth,
                    rectHeight: eventData.SnapshotHighlightRectHeight
                };
                node._reportAdditionalData.highlightArea = this._getSnapshotHighlightArea(snapshotData);
            }

        }
        catch (error) {
            this._logger.error("onAfterOperation - failed. error:" + error);
        }
    },

    _onHandleErrorOperation: function (data) {
        var node = this._reportNodesMap[data.commandId];

        if (!node)
            return;

        node._status = Status.Failed;
        node._exception = data.error;
        node._duration = this._calculateDuration(node);
        var testObjectList = node._objectPath;


        if (testObjectList && testObjectList.length > 0 && node._nativeType) {
            var lastTestObjectInPath = testObjectList[testObjectList.length - 1];
            var objectName = lastTestObjectInPath.Name;

            // if the name that was returned by UFT equals its nativeclass - then put LeanFT type instead.
            // for example [WinButton] => Button
            if (node._nativeType === objectName) {
                lastTestObjectInPath.Name = "[" + this._getLeanFtTypeFromTestObject(data.testObject) + "]";
                node._name = lastTestObjectInPath.Type + "." + node._operation;
            }
        }

        this._addNodeToReportModel(node);
    },

    _updateHierarchyNames: function (testObject, names, hierarchy) {
        if (!testObject || !hierarchy)
            return;

        names = names.reverse();
        names.forEach(function (name, i) {
            hierarchy[i].Name = this._getDisplayName(testObject, name);
        }, this);
    },

    _getArgumentsTable: function (data) {
        if (data.methodArguments.length === 0)
            return;

        var argumentNames = ReportUtils.getParamNames(data.method, data.methodArguments) || [];

        // fill the argument names in the node description
        argumentNames = argumentNames.map(function (name, i) {
            return {name: name, value: data.methodArguments[i]};
        });

        return this.buildArgumentsTable(argumentNames);
    },

    _getTOProperties: function (testObject) {
        // set the properties value
        var description = testObject._description || {};

        var descriptionProperties = [];

        for (var key in description) {
            if (typeof(description[key]) === "function" && key[0] !== '_' && key.toString() !== "constructor") {
                descriptionProperties.push(key);
            }
        }

        var properties = descriptionProperties.map(function (key) {
            var value = description[key]();
            if (value === undefined || value === null)
                return null;

            var propertyValue = this._propertyValueHandler[typeof(value)](value);

            if (propertyValue === null || Number.isNaN(value))
                return null;

            return {name: key, value: propertyValue};
        }, this).filter(function (value) {
            return value !== null;
        });
        return properties;
    },

    _specialValueHandler: {
        TestObject: function (data) {
            var testObject = data.sender;
            var properties = this._getTOProperties(testObject);

            var objectHierarchy = this._getTestObjectHierarchy(testObject);
            var node = new RunUnitOperationNode(
                {
                    objectType: this._getLeanFtTypeFromTestObject(testObject),
                    technology: this._getTechnologyFromTestObject(testObject),
                    operation: data.methodName,
                    properties: properties,
                    objectPath: objectHierarchy,
                    name: objectHierarchy[objectHierarchy.length - 1].Name + "." + data.methodName,
                });

            node._description = this._getArgumentsTable(data, node) || "";
            return node;
        },

        BrowserFactory: function (data) {
            var browserType = "";

            if (data.methodName === "launch" || data.methodName === "launchEmulated") {
                //  for example "Chrome"
                browserType = data.methodArguments[0];
            }
            else {
                var browserFilter = data.methodArguments[0];
                if (!browserFilter || !browserFilter.type) {
                    browserType = "";
                }
                else {
                    browserType = browserFilter.type;
                }
            }

            var browserNode = new RunUnitOperationNode(
                {
                    name: "Browser." + data.methodName,
                    objectType: "Browser",
                    technology: "Web",
                    operation: data.methodName,
                });

            browserNode._description = this._getArgumentsTable(data, browserNode) || "";

            // hints to XmlReport that need to replace title with new title
            var titleToPresent = "Browser.<span class='emphasis'>" + data.methodName + "(" + browserType + ")</span>";
            var titleToolTip = browserNode._name + "(\"" + browserType + "\")";

            browserNode._reportAdditionalData[Const.Title] = titleToPresent;
            browserNode._reportAdditionalData[Const.TitleToolTip] = titleToolTip;

            return browserNode;
        },

        MobileLab: function (data) {
            var operationTitle = data.methodArguments[0].name ? "Device.Lock(\"" + data.methodArguments[0].name + "\")" : "Device.Lock";


            var mobileNode = new RunUnitOperationNode(
                {
                    name: operationTitle,
                    objectType: "Device",
                    technology: "Mobile",
                    operation: data.methodName,
                });

            mobileNode._description = this._getArgumentsTable(data, mobileNode) || "";

            // hints to XmlReport that need to replace title with new title
            var titleToPresent = this._specialValueHandler.getBoldOperationTitle(operationTitle);
            var titleToolTip = operationTitle;

            mobileNode._reportAdditionalData[Const.Title] = titleToPresent;
            mobileNode._reportAdditionalData[Const.TitleToolTip] = titleToolTip;

            return mobileNode;
        },

        NativeObject: function (data){
            var node = this._nativeObjectsMap[data.sender._proxyId].cloneNode();
            node._operation = "NativeObject" + '.' + data.methodName;
            node._name = node._name.substring(0, node._name.indexOf('.')) + '.' + node._operation;
            node._description = "";
            node._time = ReportUtils.getCurrentDateTime();

            return node;
        },

        BitmapCheckpoint: function (data) {
            var testObject = data.sender;
            var node = this._specialValueHandler.TestObject.call(this, data);
            var operationTitle = node._objectPath[node._objectPath.length - 1].Name + "." + data.methodName;
            node._nodeType = RunUnitNodeType.Mix;

            // save first argument tp file
            this._addSnapshotForOperation(node, data.methodArguments[0], function(result){
                node._reportAdditionalData.firstImage = result.path;
            });

            // save test object snapshot to file
            testObject.snapshot().then(function(base64Img){
                this._addSnapshotForOperation(node,base64Img,
                    function(result){
                        node._reportAdditionalData.secondImage = result.path;
                    });
            }.bind(this));

            testObject._session._promiseManager.rootBranchThen(function(){testObject.exists();});

            node._description = this._getArgumentsTable(data, node) || "";

            // hints to XmlReport that need to replace title with new title
            var titleToPresent = this._specialValueHandler.getBoldOperationTitle(operationTitle);
            var titleToolTip = operationTitle;

            node._reportAdditionalData[Const.Title] = titleToPresent;
            node._reportAdditionalData[Const.TitleToolTip] = titleToolTip;

            var argumentNames = ReportUtils.getParamNames(data.method, data.methodArguments) || [];

            // fill the argument names in the node additional data
            argumentNames.map(function (name, i) {
                node._reportAdditionalData[name] = data.methodArguments[i];
            });

            return node;
        },

        getBoldOperationTitle : function(operationTitle){
            var firstIndexOfChar = operationTitle.indexOf('.');
            if (firstIndexOfChar > -1){
                return [operationTitle.slice(0, firstIndexOfChar + 1), "<span class='emphasis'>", operationTitle.slice(firstIndexOfChar + 1)].join('') + "</span>";
            }

            return "<span class='emphasis'>" + operationTitle + "</span>";
        }
    },

    _specialValueResultHandler: {
        BitmapCheckpoint: function (node, result) {
            var operationTitle = node._objectPath[node._objectPath.length - 1].Name + "." + node._operation;

            // hints to XmlReport that need to replace title with new title
            var titleToPresent = this._specialValueHandler.getBoldOperationTitle(operationTitle);
            var titleToolTip = operationTitle;

            node._reportAdditionalData[Const.Title] = titleToPresent;
            node._reportAdditionalData[Const.TitleToolTip] = titleToolTip;

            if (!result)
                return;

            // verifyImageMatch
            function removeCaptureData(node) {
                function removeKey(data,key){
                    if (data[key]){
                        delete data[key];
                    }
                }

                removeKey(node._reportAdditionalData,"firstImage");
                removeKey(node._reportAdditionalData,"secondImage");
                removeKey(node._reportAdditionalData,"deltaImage");
            }

            if (result.ImagesMatch !== undefined){
                this._addSnapshotForOperation(node, result.EncodedDiffImage, function(result){
                    node._reportAdditionalData.deltaImage = result.path;
                });

                node._status = result.ImagesMatch ? Status.Passed : Status.Failed;

                if (node._status === Status.Passed)
                {
                    node._description = node._description + Const.HtmlTableCssStyle +
                        "<p><div class=data-label>Result</div>The test object matches the image</p>";

                    if ((node._reportAdditionalData.pixelTolerance === 0 && node._reportAdditionalData.rgbTolerance === 0)){
                        removeCaptureData(node);
                    }
                }
                else
                {
                    node._description = node._description + Const.HtmlTableCssStyle +
                        "<p><div class=data-label>Result</div>The test object does not match the image</p>";
                }
            }
            else{
                var existResult = {
                    actualSimilarity: result.Similarity,
                    point: {
                        x: result.X,
                        y: result.Y
                    }};

                var value = this._argumentValueHandler[typeof(existResult.point)].call(this, existResult.point);
                var similarity = node._reportAdditionalData.similarity || 100;
                if (result && existResult.actualSimilarity >= similarity) {
                    node._status = Status.Passed;

                    node._description = node._description + Const.HtmlTableCssStyle +
                        "<p><div class=data-label>Result</div> Image was located successfully" + value + "</p>";

                    // remove the additional data if similarity equals 100
                    if (node._reportAdditionalData.actualSimilarity === 100) {
                        removeCaptureData(node);
                    }
                    return;
                }

                node._status = Status.Failed;
                node._description = node._description + Const.HtmlTableCssStyle + "<p><div class=data-label>Result</div>Could not locate image</p>";

                removeCaptureData(node);
            }
        }
    },

    _propertyValueHandler: {
        object: function (value) {
            if (Array.isArray(value)) {
                return value.map(function (item) {
                    return this[typeof(item)](item);
                }, this).join(", ");
            }

            if (value._keyPrefix || value._keysMap) {
                var values = [];
                for (var item in value) {
                    // check if it's public method
                    if (item[0] !== '_') {
                        var key = this[typeof(item)](item);
                        var result = this[typeof(value[item])](value[item]);
                        values.push({key: key, value: result});
                    }
                }

                if (values.length === 0)
                    return null;

                if (value._keyPrefix) {
                    return "{" + values.map(function (item) {
                            return "{" + item.key + " ," + item.value + "}";
                        }).join(", ") + "}";
                }
                return "{" + values.map(function (item) {
                        return "{" + item.key.replace(/['"]+/g, '') + " = " + item.value + "}";
                    }).join(", ") + "}";
            }
            return value.toString();
        },

        string: function (value) {
            return "\"" + value + "\"";
        },

        number: function (value) {
            return value;
        },
    },

    _argumentValueHandler: {
        object: function (value) {
            if (value === null){
                return 'null';
            }

            // test object case
            if (value._description) {
                return this._argumentValueHandler.testObject.call(this, value);
            }

            var sb = Const.HtmlTableCssStyle + "<table class='ex-table'>";
            Object.keys(value).forEach(function (item) {
                sb += "<tr><td class='ex-name'>" + item + "</td><td class='ex-value'>" + this._argumentValueHandler[typeof(value[item])].call(this, value[item]) + "</td></tr>";
            }, this);
            sb += "</table>";
            return sb;
        },

        testObject: function(value){
            var sb = "";
            this.getDescriptionTable = function (testObject) {
                var properties = this._getTOProperties(testObject);
                sb = Const.HtmlTableCssStyle + "<table class='ex-table'>";

                properties.forEach(function (property) {
                    sb += "<tr><td class='ex-name'>" + property.name + "</td><td class='ex-value'>" + property.value + "</td></tr>";
                });
                sb += "</table>";
                return sb;
            };

            var testObject = value;
            sb = Const.HtmlTableCssStyle + "<table class='ex-table'>";

            // display name will be presented only if exist
            if (testObject.displayName) {
                sb += "<tr><td class='ex-name'>DisplayName</td><td class='ex-value'>testObject.displayName</td></tr>";
            }

            sb += "<tr><td class='ex-name'>Description</td><td class='ex-value'>" + this.getDescriptionTable(testObject) + "</td></tr></table>";
            return sb;
        },

        string: function (value) {
            var regex = new RegExp('(?:^(?:[A-Za-z0-9+\/]{4}\\n?)*(?:[A-Za-z0-9+\/]{2}==|[A-Za-z0-9+\/]{3}=)$)');

            // check if string is base64 image string
            var match = value.match(regex);
            if (match){
                return this._argumentValueHandler.image.call(this, value);
            }

            return value;
        },

        image : function(value){
            var imageRelativePath = Path.join(Const.SnapshotsFolder, ReportUtils.generateUUID() + ".png");
            var imageFullPath = Path.join(ReporterProvider.prototype._runtimeSettings._generatedReportPath, imageRelativePath);
            ReportUtils.base64_decode(value, imageFullPath);
            return "<img src='" + imageRelativePath + "\' height='40' width='40' style = \'cursor: pointer;\' onclick=\'__uiElements.show_image_viewer_in_float_pane_by_imgelement(this) \'>";
        },

        number: function (value) {
            return value;
        },

        boolean: function (value) {
            return value;
        },
    },

    buildArgumentsTable: function (data) {
        if (data.length === 0)
            return "";

        var sb = Const.HtmlTableCssStyle + "<table class='ex-table'>";
        for (var i = 0; i < data.length; i++) {
            if (data[i].value === undefined)
                continue;

            sb += "<tr><td class='ex-name'>" + data[i].name + "</td><td class='ex-value'>" + this._argumentValueHandler[typeof(data[i].value)].call(this, data[i].value) + "</td></tr>";
        }
        sb += ("</table>");
        return sb;
    },
};

module.exports.ReporterProvider = ReporterProvider;


// SIG // Begin signature block
// SIG // MIIdqgYJKoZIhvcNAQcCoIIdmzCCHZcCAQExDzANBglg
// SIG // hkgBZQMEAgEFADB3BgorBgEEAYI3AgEEoGkwZzAyBgor
// SIG // BgEEAYI3AgEeMCQCAQEEEBDgyQbOONQRoqMAEEvTUJAC
// SIG // AQACAQACAQACAQACAQAwMTANBglghkgBZQMEAgEFAAQg
// SIG // cbc2hx/nrFlMgpLSr77CZMJmIM3pCO1t0IKCs9Sqp1eg
// SIG // ghi2MIID7jCCA1egAwIBAgIQfpPr+3zGTlnqS5p31Ab8
// SIG // OzANBgkqhkiG9w0BAQUFADCBizELMAkGA1UEBhMCWkEx
// SIG // FTATBgNVBAgTDFdlc3Rlcm4gQ2FwZTEUMBIGA1UEBxML
// SIG // RHVyYmFudmlsbGUxDzANBgNVBAoTBlRoYXd0ZTEdMBsG
// SIG // A1UECxMUVGhhd3RlIENlcnRpZmljYXRpb24xHzAdBgNV
// SIG // BAMTFlRoYXd0ZSBUaW1lc3RhbXBpbmcgQ0EwHhcNMTIx
// SIG // MjIxMDAwMDAwWhcNMjAxMjMwMjM1OTU5WjBeMQswCQYD
// SIG // VQQGEwJVUzEdMBsGA1UEChMUU3ltYW50ZWMgQ29ycG9y
// SIG // YXRpb24xMDAuBgNVBAMTJ1N5bWFudGVjIFRpbWUgU3Rh
// SIG // bXBpbmcgU2VydmljZXMgQ0EgLSBHMjCCASIwDQYJKoZI
// SIG // hvcNAQEBBQADggEPADCCAQoCggEBALGss0lUS5ccEgrY
// SIG // JXmRIlcqb9y4JsRDc2vCvy5QWvsUwnaOQwElQ7Sh4kX0
// SIG // 6Ld7w3TMIte0lAAC903tv7S3RCRrzV9FO9FEzkMScxeC
// SIG // i2m0K8uZHqxyGyZNcR+xMd37UWECU6aq9UksBXhFpS+J
// SIG // zueZ5/6M4lc/PcaS3Er4ezPkeQr78HWIQZz/xQNRmarX
// SIG // bJ+TaYdlKYOFwmAUxMjJOxTawIHwHw103pIiq8r3+3R8
// SIG // J+b3Sht/p8OeLa6K6qbmqicWfWH3mHERvOJQoUvlXfrl
// SIG // Dqcsn6plINPYlujIfKVOSET/GeJEB5IL12iEgF1qeGRF
// SIG // zWBGflTBE3zFefHJwXECAwEAAaOB+jCB9zAdBgNVHQ4E
// SIG // FgQUX5r1blzMzHSa1N197z/b7EyALt0wMgYIKwYBBQUH
// SIG // AQEEJjAkMCIGCCsGAQUFBzABhhZodHRwOi8vb2NzcC50
// SIG // aGF3dGUuY29tMBIGA1UdEwEB/wQIMAYBAf8CAQAwPwYD
// SIG // VR0fBDgwNjA0oDKgMIYuaHR0cDovL2NybC50aGF3dGUu
// SIG // Y29tL1RoYXd0ZVRpbWVzdGFtcGluZ0NBLmNybDATBgNV
// SIG // HSUEDDAKBggrBgEFBQcDCDAOBgNVHQ8BAf8EBAMCAQYw
// SIG // KAYDVR0RBCEwH6QdMBsxGTAXBgNVBAMTEFRpbWVTdGFt
// SIG // cC0yMDQ4LTEwDQYJKoZIhvcNAQEFBQADgYEAAwmbj3nv
// SIG // f1kwqu9otfrjCR27T4IGXTdfplKfFo3qHJIJRG71betY
// SIG // fDDo+WmNI3MLEm9Hqa45EfgqsZuwGsOO61mWAK3ODE2y
// SIG // 0DGmCFwqevzieh1XTKhlGOl5QGIllm7HxzdqgyEIjkHq
// SIG // 3dlXPx13SYcqFgZepjhqIhKjURmDfrYwggSjMIIDi6AD
// SIG // AgECAhAOz/Q4yP6/NW4E2GqYGxpQMA0GCSqGSIb3DQEB
// SIG // BQUAMF4xCzAJBgNVBAYTAlVTMR0wGwYDVQQKExRTeW1h
// SIG // bnRlYyBDb3Jwb3JhdGlvbjEwMC4GA1UEAxMnU3ltYW50
// SIG // ZWMgVGltZSBTdGFtcGluZyBTZXJ2aWNlcyBDQSAtIEcy
// SIG // MB4XDTEyMTAxODAwMDAwMFoXDTIwMTIyOTIzNTk1OVow
// SIG // YjELMAkGA1UEBhMCVVMxHTAbBgNVBAoTFFN5bWFudGVj
// SIG // IENvcnBvcmF0aW9uMTQwMgYDVQQDEytTeW1hbnRlYyBU
// SIG // aW1lIFN0YW1waW5nIFNlcnZpY2VzIFNpZ25lciAtIEc0
// SIG // MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA
// SIG // omMLOUS4uyOnREm7Dv+h8GEKU5OwmNutLA9KxW7/hjxT
// SIG // VQ8VzgQ/K/2plpbZvmF5C1vJTIZ25eBDSyKV7sIrQ8Gf
// SIG // 2Gi0jkBP7oU4uRHFI/JkWPAVMm9OV6GuiKQC1yoezUvh
// SIG // 3WPVF4kyW7BemVqonShQDhfultthO0VRHc8SVguSR/yr
// SIG // rvZmPUescHLnkudfzRC5xINklBm9JYDh6NIipdC6Anqh
// SIG // d5NbZcPuF3S8QYYq3AhMjJKMkS2ed0QfaNaodHfbDlsy
// SIG // i1aLM73ZY8hJnTrFxeozC9Lxoxv0i77Zs1eLO94Ep3oi
// SIG // siSuLsdwxb5OgyYI+wu9qU+ZCOEQKHKqzQIDAQABo4IB
// SIG // VzCCAVMwDAYDVR0TAQH/BAIwADAWBgNVHSUBAf8EDDAK
// SIG // BggrBgEFBQcDCDAOBgNVHQ8BAf8EBAMCB4AwcwYIKwYB
// SIG // BQUHAQEEZzBlMCoGCCsGAQUFBzABhh5odHRwOi8vdHMt
// SIG // b2NzcC53cy5zeW1hbnRlYy5jb20wNwYIKwYBBQUHMAKG
// SIG // K2h0dHA6Ly90cy1haWEud3Muc3ltYW50ZWMuY29tL3Rz
// SIG // cy1jYS1nMi5jZXIwPAYDVR0fBDUwMzAxoC+gLYYraHR0
// SIG // cDovL3RzLWNybC53cy5zeW1hbnRlYy5jb20vdHNzLWNh
// SIG // LWcyLmNybDAoBgNVHREEITAfpB0wGzEZMBcGA1UEAxMQ
// SIG // VGltZVN0YW1wLTIwNDgtMjAdBgNVHQ4EFgQURsZpow5K
// SIG // FB7VTNpSYxc/Xja8DeYwHwYDVR0jBBgwFoAUX5r1blzM
// SIG // zHSa1N197z/b7EyALt0wDQYJKoZIhvcNAQEFBQADggEB
// SIG // AHg7tJEqAEzwj2IwN3ijhCcHbxiy3iXcoNSUA6qGTiWf
// SIG // mkADHN3O43nLIWgG2rYytG2/9CwmYzPkSWRtDebDZw73
// SIG // BaQ1bHyJFsbpst+y6d0gxnEPzZV03LZc3r03H0N45ni1
// SIG // zSgEIKOq8UvEiCmRDoDREfzdXHZuT14ORUZBbg2w6jia
// SIG // sTraCXEQ/Bx5tIB7rGn0/Zy2DBYr8X9bCT2bW+IWyhOB
// SIG // bQAuOA2oKY8s4bL0WqkBrxWcLC9JG9siu8P+eJRRw4ax
// SIG // gohd8D20UaF5Mysue7ncIAkTcetqGVvP6KUwVyyJST+5
// SIG // z3/Jvz4iaGNTmr1pdKzFHTx/kuDDvBzYBHUwggUeMIIE
// SIG // BqADAgECAhBBOdHLco8U0T0ppjKaGuk8MA0GCSqGSIb3
// SIG // DQEBCwUAMH8xCzAJBgNVBAYTAlVTMR0wGwYDVQQKExRT
// SIG // eW1hbnRlYyBDb3Jwb3JhdGlvbjEfMB0GA1UECxMWU3lt
// SIG // YW50ZWMgVHJ1c3QgTmV0d29yazEwMC4GA1UEAxMnU3lt
// SIG // YW50ZWMgQ2xhc3MgMyBTSEEyNTYgQ29kZSBTaWduaW5n
// SIG // IENBMB4XDTE2MDMyMjAwMDAwMFoXDTE3MDMyMzIzNTk1
// SIG // OVowgaQxCzAJBgNVBAYTAlVTMRMwEQYDVQQIDApDYWxp
// SIG // Zm9ybmlhMRIwEAYDVQQHDAlQYWxvIEFsdG8xKzApBgNV
// SIG // BAoMIkhld2xldHQgUGFja2FyZCBFbnRlcnByaXNlIENv
// SIG // bXBhbnkxEjAQBgNVBAsMCUNvZGUgU2lnbjErMCkGA1UE
// SIG // AwwiSGV3bGV0dCBQYWNrYXJkIEVudGVycHJpc2UgQ29t
// SIG // cGFueTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoC
// SIG // ggEBAMGgAXZcNuvF8MzEBQ9daA+60G+7667OIG2+jYQP
// SIG // NjCrcfmj+1/tNB/NRPBUAuITQCmENam4I7imHQH7Lg2O
// SIG // ilNADlkdTg2sQyvYh/vIKiLeKK1vgFOwXuqcG7Ls6xsL
// SIG // dJFhsMsq/7cSXJdWNN58wij65A0qXM3/uwcEVuayJ0XH
// SIG // KsOJoFVQD1VNBS2Y64bcAVUXvgWnmVbH/mP63s7pdjKo
// SIG // NeVOnJy8axVByDRm75M83uOQqhLhGhBxmJnWdTm1sl7L
// SIG // Drc3gZq8dPTADSUwGtkXY67vgZO4BkLxHzelYu2OMUoQ
// SIG // 8JlFDd0usxwKseyg0ZWihFUumC0kCzuv0fq1qhUCAwEA
// SIG // AaOCAW4wggFqMAkGA1UdEwQCMAAwDgYDVR0PAQH/BAQD
// SIG // AgeAMBMGA1UdJQQMMAoGCCsGAQUFBwMDMGYGA1UdIARf
// SIG // MF0wWwYLYIZIAYb4RQEHFwMwTDAjBggrBgEFBQcCARYX
// SIG // aHR0cHM6Ly9kLnN5bWNiLmNvbS9jcHMwJQYIKwYBBQUH
// SIG // AgIwGRoXaHR0cHM6Ly9kLnN5bWNiLmNvbS9ycGEwHwYD
// SIG // VR0jBBgwFoAUljtT8Hkzl699g+8uK8zKt4YecmYwKwYD
// SIG // VR0fBCQwIjAgoB6gHIYaaHR0cDovL3N2LnN5bWNiLmNv
// SIG // bS9zdi5jcmwwVwYIKwYBBQUHAQEESzBJMB8GCCsGAQUF
// SIG // BzABhhNodHRwOi8vc3Yuc3ltY2QuY29tMCYGCCsGAQUF
// SIG // BzAChhpodHRwOi8vc3Yuc3ltY2IuY29tL3N2LmNydDAR
// SIG // BglghkgBhvhCAQEEBAMCBBAwFgYKKwYBBAGCNwIBGwQI
// SIG // MAYBAQABAf8wDQYJKoZIhvcNAQELBQADggEBAIVbsb1l
// SIG // QffQZ4Ry6IkXNI1/mSIscM5U4vosrSwOou3nypo2QHpl
// SIG // C0BoUcSlavhAQ8cA5kwlxN4H+zb7bnB2lrvxCIjDT2/+
// SIG // uwWDLb1Z3GBV/Dneyr6uSKE9aUjKE7S5v7WabLcCPj1v
// SIG // 1/p6wNkPR+3czu839mJbuVOR8okTWwjZjZgs9ommE+53
// SIG // fE1cxdqzz+hD+Dukbos3+PdYaaVA2/lHoFWVlj1B9oig
// SIG // Bsv1ZbagBuEVtF1fb8uY8tDWnd4QDKE7vcq52tm9L7Xz
// SIG // B3SIyc+UTUi5BECXpqXsAHhQ9So5frKvWsELbOst/lOD
// SIG // zzMTGlOlyW6R3mc9zILt2m5Vdg4wggVZMIIEQaADAgEC
// SIG // AhA9eNf5dklgsmF99PAeyoYqMA0GCSqGSIb3DQEBCwUA
// SIG // MIHKMQswCQYDVQQGEwJVUzEXMBUGA1UEChMOVmVyaVNp
// SIG // Z24sIEluYy4xHzAdBgNVBAsTFlZlcmlTaWduIFRydXN0
// SIG // IE5ldHdvcmsxOjA4BgNVBAsTMShjKSAyMDA2IFZlcmlT
// SIG // aWduLCBJbmMuIC0gRm9yIGF1dGhvcml6ZWQgdXNlIG9u
// SIG // bHkxRTBDBgNVBAMTPFZlcmlTaWduIENsYXNzIDMgUHVi
// SIG // bGljIFByaW1hcnkgQ2VydGlmaWNhdGlvbiBBdXRob3Jp
// SIG // dHkgLSBHNTAeFw0xMzEyMTAwMDAwMDBaFw0yMzEyMDky
// SIG // MzU5NTlaMH8xCzAJBgNVBAYTAlVTMR0wGwYDVQQKExRT
// SIG // eW1hbnRlYyBDb3Jwb3JhdGlvbjEfMB0GA1UECxMWU3lt
// SIG // YW50ZWMgVHJ1c3QgTmV0d29yazEwMC4GA1UEAxMnU3lt
// SIG // YW50ZWMgQ2xhc3MgMyBTSEEyNTYgQ29kZSBTaWduaW5n
// SIG // IENBMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKC
// SIG // AQEAl4MeABavLLHSCMTXaJNRYB5x9uJHtNtYTSNiarS/
// SIG // WhtR96MNGHdou9g2qy8hUNqe8+dfJ04LwpfICXCTqdpc
// SIG // DU6kDZGgtOwUzpFyVC7Oo9tE6VIbP0E8ykrkqsDoOatT
// SIG // zCHQzM9/m+bCzFhqghXuPTbPHMWXBySO8Xu+MS09bty1
// SIG // mUKfS2GVXxxw7hd924vlYYl4x2gbrxF4GpiuxFVHU9mz
// SIG // MtahDkZAxZeSitFTp5lbhTVX0+qTYmEgCscwdyQRTWKD
// SIG // trp7aIIx7mXK3/nVjbI13Iwrb2pyXGCEnPIMlF7AVlIA
// SIG // SMzT+KV93i/XE+Q4qITVRrgThsIbnepaON2b2wIDAQAB
// SIG // o4IBgzCCAX8wLwYIKwYBBQUHAQEEIzAhMB8GCCsGAQUF
// SIG // BzABhhNodHRwOi8vczIuc3ltY2IuY29tMBIGA1UdEwEB
// SIG // /wQIMAYBAf8CAQAwbAYDVR0gBGUwYzBhBgtghkgBhvhF
// SIG // AQcXAzBSMCYGCCsGAQUFBwIBFhpodHRwOi8vd3d3LnN5
// SIG // bWF1dGguY29tL2NwczAoBggrBgEFBQcCAjAcGhpodHRw
// SIG // Oi8vd3d3LnN5bWF1dGguY29tL3JwYTAwBgNVHR8EKTAn
// SIG // MCWgI6Ahhh9odHRwOi8vczEuc3ltY2IuY29tL3BjYTMt
// SIG // ZzUuY3JsMB0GA1UdJQQWMBQGCCsGAQUFBwMCBggrBgEF
// SIG // BQcDAzAOBgNVHQ8BAf8EBAMCAQYwKQYDVR0RBCIwIKQe
// SIG // MBwxGjAYBgNVBAMTEVN5bWFudGVjUEtJLTEtNTY3MB0G
// SIG // A1UdDgQWBBSWO1PweTOXr32D7y4rzMq3hh5yZjAfBgNV
// SIG // HSMEGDAWgBR/02Wnwt3su/AwCfNDOfoCrzMxMzANBgkq
// SIG // hkiG9w0BAQsFAAOCAQEAE4UaHmmpN/egvaSvfh1hU/6d
// SIG // jF4MpnUeeBcj3f3sGgNVOftxlcdlWqeOMNJEWmHbcG/a
// SIG // IQXCLnO6SfHRk/5dyc1eA+CJnj90Htf3OIup1s+7NS8z
// SIG // WKiSVtHITTuC5nmEFvwosLFH8x2iPu6H2aZ/pFalP62E
// SIG // LinefLyoqqM9BAHqupOiDlAiKRdMh+Q6EV/WpCWJmwVr
// SIG // L7TJAUwnewusGQUioGAVP9rJ+01Mj/tyZ3f9J5THujUO
// SIG // iEn+jf0or0oSvQ2zlwXeRAwV+jYrA9zBUAHxoRFdFOXi
// SIG // vSdLVL4rhF4PpsN0BQrvl8OJIrEfd/O9zUPU8UypP7WL
// SIG // hK9k8tAUITCCBZowggOCoAMCAQICCmEZk+QAAAAAABww
// SIG // DQYJKoZIhvcNAQEFBQAwfzELMAkGA1UEBhMCVVMxEzAR
// SIG // BgNVBAgTCldhc2hpbmd0b24xEDAOBgNVBAcTB1JlZG1v
// SIG // bmQxHjAcBgNVBAoTFU1pY3Jvc29mdCBDb3Jwb3JhdGlv
// SIG // bjEpMCcGA1UEAxMgTWljcm9zb2Z0IENvZGUgVmVyaWZp
// SIG // Y2F0aW9uIFJvb3QwHhcNMTEwMjIyMTkyNTE3WhcNMjEw
// SIG // MjIyMTkzNTE3WjCByjELMAkGA1UEBhMCVVMxFzAVBgNV
// SIG // BAoTDlZlcmlTaWduLCBJbmMuMR8wHQYDVQQLExZWZXJp
// SIG // U2lnbiBUcnVzdCBOZXR3b3JrMTowOAYDVQQLEzEoYykg
// SIG // MjAwNiBWZXJpU2lnbiwgSW5jLiAtIEZvciBhdXRob3Jp
// SIG // emVkIHVzZSBvbmx5MUUwQwYDVQQDEzxWZXJpU2lnbiBD
// SIG // bGFzcyAzIFB1YmxpYyBQcmltYXJ5IENlcnRpZmljYXRp
// SIG // b24gQXV0aG9yaXR5IC0gRzUwggEiMA0GCSqGSIb3DQEB
// SIG // AQUAA4IBDwAwggEKAoIBAQCvJAgIKXo1nmAMqudLO07c
// SIG // fLw8RRy7K+D+KQL5VwijZIUVJ/XxrcgxiV0i6CqqpkKz
// SIG // j/i5Vbext0uz/o9+B1fs70PbZmIVYc9gDaTY3vjgw2II
// SIG // PVQT60nKWVSFJuUrjxuf6/WhkcIzSdhDY2pSS9KP6HBR
// SIG // TdGJaXvHcPaz3BJ023tdS1bTlr8Vd6Gw9KIl8q8ckmcY
// SIG // 5fQGBO+QueQA5N06tRn/Arr0PO7gi+s3i+z016zy9vA9
// SIG // r911kTMZHRxAy3QkGSGT2RT+rCpSx4/VBEnkjWNHiDxp
// SIG // g8v+R70rfk/Fla4OndTRQ8Bnc+MUCH7lP59zuDMKz10/
// SIG // NIeWiu5T6CUVAgMBAAGjgcswgcgwEQYDVR0gBAowCDAG
// SIG // BgRVHSAAMA8GA1UdEwEB/wQFMAMBAf8wCwYDVR0PBAQD
// SIG // AgGGMB0GA1UdDgQWBBR/02Wnwt3su/AwCfNDOfoCrzMx
// SIG // MzAfBgNVHSMEGDAWgBRi+wohW39DbhHaCVRQa/XSlnHx
// SIG // njBVBgNVHR8ETjBMMEqgSKBGhkRodHRwOi8vY3JsLm1p
// SIG // Y3Jvc29mdC5jb20vcGtpL2NybC9wcm9kdWN0cy9NaWNy
// SIG // b3NvZnRDb2RlVmVyaWZSb290LmNybDANBgkqhkiG9w0B
// SIG // AQUFAAOCAgEAgSqCFow0ZyvlA+s0e4yio1CK9FWG8R6M
// SIG // jq597gMZznKVGEitYhH9IP0/RwYBWuLgb4wVLE48alBs
// SIG // Czajz3oNnEK8XPgZ1WDjaebiI0FnjGiDdiuPk6MqtX++
// SIG // WfupybImj8qi84IbmD6RlSeXhmHuW10Ha82GqOJlgKji
// SIG // FeKyviMFaroM80eTTaykjAd5OcBhEjoFDYmj7J9XiYT7
// SIG // 7Mp8R2YUkdi2Dxld5rhKrLxHyHFDluYyIKXcd4b9POOL
// SIG // cdt7mwP8tx0yZOsWUqBDo/ourVmSTnzH8jNCSDhROnw4
// SIG // xxskIihAHhpGHxfbGPfwJzVsuGPZzblkXSulXu/GKbTy
// SIG // x/ghzAS6V/0BtqvGZ/nn05l/9PUi+nL1/f86HEI6ofmA
// SIG // GKXujRzUZp5FAf6q7v/7F48w9/HNKcWd7LXVSQA9hbjL
// SIG // u5M6J2pJwDCuZsn3Iygydvmkg1bISM5alqqgzAzEf7SO
// SIG // l69t41Qnw5+GwNbkcwiXBdvQVGJeA0jC1Z9/p2aM0J2w
// SIG // T9TTmF9Lesl/silS0BKAxw9Uth5nzcagbBEDhNNIdecq
// SIG // /rA7bgo6pmt2mQWj8XdoYTMURwb8U39SvZIUXEokameM
// SIG // r42QqtD2eSEbkyZ8w84evYg4kq5FxhlqSVCzBfiuWTeK
// SIG // aiUDlLFZgVDouoOAtyM19Ha5Zx1ZGK0gjZQxggRMMIIE
// SIG // SAIBATCBkzB/MQswCQYDVQQGEwJVUzEdMBsGA1UEChMU
// SIG // U3ltYW50ZWMgQ29ycG9yYXRpb24xHzAdBgNVBAsTFlN5
// SIG // bWFudGVjIFRydXN0IE5ldHdvcmsxMDAuBgNVBAMTJ1N5
// SIG // bWFudGVjIENsYXNzIDMgU0hBMjU2IENvZGUgU2lnbmlu
// SIG // ZyBDQQIQQTnRy3KPFNE9KaYymhrpPDANBglghkgBZQME
// SIG // AgEFAKB8MBAGCisGAQQBgjcCAQwxAjAAMBkGCSqGSIb3
// SIG // DQEJAzEMBgorBgEEAYI3AgEEMBwGCisGAQQBgjcCAQsx
// SIG // DjAMBgorBgEEAYI3AgEVMC8GCSqGSIb3DQEJBDEiBCAu
// SIG // NxSwG6UeEsA0k48Ddhe1LAlNSLWCkXj86rzAIFLThjAN
// SIG // BgkqhkiG9w0BAQEFAASCAQC8GwWblo5ZPVgb5LNq4+T7
// SIG // fvnpQjamViaB4MwKmcUjVqWlO5wFKJl6Ky9NHhmklq+y
// SIG // DsBKaDAnmG+ytABAxaVfSmSmQuuZVn2rLsQwc6Ydawuo
// SIG // mh6CvMyE3Hqmxmo1Om8/FyJvn+ptnOHneg0A/Vk5VRWj
// SIG // uqfaFiTv3O/T9VF70iQOLorVTV5xm76wpbNqvoxBVQFd
// SIG // fvUk0PJOAxvRNdkUSiNMVemgObIQYmLKWJjdTBdxDk+i
// SIG // J7A6VU5BBSHfiN6Fr3cq5cVnlB7Qd6SlZhdSTHda5Jk1
// SIG // /U0Yn4tXQtLe7bw9XTx/3MR8nGAl4wg/PmREFwWclFfR
// SIG // eatIxUgAhKJloYICCzCCAgcGCSqGSIb3DQEJBjGCAfgw
// SIG // ggH0AgEBMHIwXjELMAkGA1UEBhMCVVMxHTAbBgNVBAoT
// SIG // FFN5bWFudGVjIENvcnBvcmF0aW9uMTAwLgYDVQQDEydT
// SIG // eW1hbnRlYyBUaW1lIFN0YW1waW5nIFNlcnZpY2VzIENB
// SIG // IC0gRzICEA7P9DjI/r81bgTYapgbGlAwCQYFKw4DAhoF
// SIG // AKBdMBgGCSqGSIb3DQEJAzELBgkqhkiG9w0BBwEwHAYJ
// SIG // KoZIhvcNAQkFMQ8XDTE2MDUyNjE0MTUxM1owIwYJKoZI
// SIG // hvcNAQkEMRYEFD6Age3l4PuGTHBAmJLmEdHiEmYFMA0G
// SIG // CSqGSIb3DQEBAQUABIIBAC0Q/bqJfHgzO0puhGLKah0d
// SIG // wgXaFptgdOmw5UuxA59topAM/YaAUhyQeh0eHCDi5A9L
// SIG // q1+JidUQ0GvRQDtXEVdMt0hqicIuNc9KnhDU4rc6qIHX
// SIG // Sni4R4baBDBdRzqjutnXKk2piFNBzOji/v/Qzu7RKLyI
// SIG // 1YmDEUvodhwyRFgKNwv7kCHsaXdjiPSM0AwfG745lyqo
// SIG // ywPVn5YW2zGnyAdYsKDTm4bzRG5gpDcuIG+jA1Gu6ZRF
// SIG // DzefdwsY19um9mEuSkVogE/741tBVdzU3PVxbNY9ib4v
// SIG // Jz9yuDrHxB6QtPOXcYjWn3PDMp47HO+tQJz09jeWUmhP
// SIG // C/ayKbNCMwc=
// SIG // End signature block
